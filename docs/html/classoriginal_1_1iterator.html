<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ORIGINAL: original::iterator&lt; TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ORIGINAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoriginal.html">original</a></li><li class="navelem"><a class="el" href="classoriginal_1_1iterator.html">iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classoriginal_1_1iterator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">original::iterator&lt; TYPE &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Base iterator interface that supports common operations for iteration.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="iterator_8h_source.html">iterator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for original::iterator&lt; TYPE &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classoriginal_1_1iterator__inherit__graph.png" border="0" usemap="#aoriginal_1_1iterator_3_01_t_y_p_e_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="aoriginal_1_1iterator_3_01_t_y_p_e_01_4_inherit__map" id="aoriginal_1_1iterator_3_01_t_y_p_e_01_4_inherit__map">
<area shape="rect" title="Base iterator interface that supports common operations for iteration." alt="" coords="797,640,905,960"/>
<area shape="rect" href="classoriginal_1_1base_iterator.html" title=" " alt="" coords="126,1147,254,1253"/>
<area shape="poly" title=" " alt="" coords="784,824,699,854,595,895,485,947,379,1010,338,1042,298,1078,233,1149,229,1145,295,1074,334,1038,376,1006,482,943,593,890,697,849,782,819"/>
<area shape="rect" href="classoriginal_1_1base_iterator.html" title=" " alt="" coords="389,1139,553,1261"/>
<area shape="poly" title=" " alt="" coords="789,870,530,1141,526,1137,785,866"/>
<area shape="rect" href="classoriginal_1_1base_iterator.html" title=" " alt="" coords="787,1147,916,1253"/>
<area shape="poly" title=" " alt="" coords="845,975,848,1147,842,1147,840,975"/>
<area shape="poly" title=" " alt="" coords="863,975,860,1147,855,1147,857,975"/>
<area shape="rect" href="classoriginal_1_1base_iterator.html" title="A base class for basic iterators." alt="" coords="975,1147,1104,1253"/>
<area shape="poly" title=" " alt="" coords="914,928,1017,1146,1012,1148,909,930"/>
<area shape="rect" href="classoriginal_1_1base_iterator.html" title="A base class for basic iterators." alt="" coords="1128,1147,1257,1253"/>
<area shape="poly" title=" " alt="" coords="919,837,968,869,1020,909,1072,955,1117,1006,1139,1040,1157,1077,1182,1146,1177,1148,1152,1079,1134,1043,1113,1010,1068,959,1017,913,964,874,916,842"/>
<area shape="rect" href="classoriginal_1_1iterable_1_1iter_adaptor.html" title="RAII wrapper for base iterators that provides standard iteration interface." alt="" coords="1281,1008,1421,1392"/>
<area shape="poly" title=" " alt="" coords="920,817,999,843,1092,883,1140,908,1187,937,1231,969,1270,1006,1284,1022,1280,1025,1267,1010,1227,973,1184,941,1138,912,1090,887,997,848,918,822"/>
<area shape="rect" href="classoriginal_1_1printable.html" title="Base class providing polymorphic string conversion capabilities." alt="" coords="617,181,770,592"/>
<area shape="poly" title=" " alt="" coords="778,600,800,657,795,659,773,602"/>
<area shape="rect" href="classoriginal_1_1cloneable.html" title="Concrete cloneable class with custom cloning behavior." alt="" coords="794,341,908,432"/>
<area shape="poly" title=" " alt="" coords="854,447,854,640,848,640,848,447"/>
<area shape="rect" href="classoriginal_1_1base_cloneable.html" title=" " alt="" coords="778,5,924,133"/>
<area shape="poly" title=" " alt="" coords="854,148,854,342,848,342,848,148"/>
<area shape="rect" href="classoriginal_1_1comparable.html" title=" " alt="" coords="933,269,1066,504"/>
<area shape="poly" title=" " alt="" coords="955,518,908,650,903,648,950,517"/>
<area shape="rect" href="classoriginal_1_1bit_set_1_1_iterator.html" title="An iterator for traversing the bits in a bitSet." alt="" coords="5,1483,153,1781"/>
<area shape="poly" title=" " alt="" coords="175,1268,120,1484,115,1482,170,1267"/>
<area shape="rect" href="classoriginal_1_1hash_map_1_1_iterator.html" title="Bidirectional iterator for hashMap." alt="" coords="177,1475,352,1789"/>
<area shape="poly" title=" " alt="" coords="438,1276,342,1476,337,1474,433,1274"/>
<area shape="rect" href="classoriginal_1_1tree_map_1_1_iterator.html" title=" " alt="" coords="376,1475,566,1789"/>
<area shape="poly" title=" " alt="" coords="474,1276,474,1475,468,1475,468,1276"/>
<area shape="rect" href="classoriginal_1_1hash_set_1_1_iterator.html" title="Forward iterator for hashSet." alt="" coords="590,1475,747,1789"/>
<area shape="poly" title=" " alt="" coords="826,1268,737,1476,732,1474,821,1266"/>
<area shape="rect" href="classoriginal_1_1tree_set_1_1_iterator.html" title=" " alt="" coords="771,1475,931,1789"/>
<area shape="poly" title=" " alt="" coords="854,1268,854,1475,848,1475,848,1268"/>
<area shape="rect" href="classoriginal_1_1blocks_list_1_1_iterator.html" title="Iterator for blocksList, supports forward and backward iteration." alt="" coords="955,1483,1123,1781"/>
<area shape="poly" title=" " alt="" coords="1042,1268,1042,1483,1036,1483,1036,1268"/>
<area shape="rect" href="classoriginal_1_1random_access_iterator.html" title="Abstract base class for random&#45;access iterators." alt="" coords="1147,1440,1334,1824"/>
<area shape="poly" title=" " alt="" coords="1067,1266,1119,1391,1149,1454,1144,1456,1114,1393,1062,1268"/>
<area shape="rect" href="classoriginal_1_1step_iterator.html" title="Abstract base class for step iterators." alt="" coords="1359,1451,1485,1813"/>
<area shape="poly" title=" " alt="" coords="1052,1267,1062,1300,1075,1333,1094,1364,1118,1390,1147,1408,1175,1416,1203,1416,1231,1413,1259,1410,1288,1411,1317,1419,1347,1438,1361,1451,1357,1455,1344,1442,1315,1424,1287,1416,1259,1416,1232,1419,1203,1422,1174,1421,1145,1413,1115,1394,1090,1367,1071,1335,1057,1301,1047,1269"/>
<area shape="rect" href="classoriginal_1_1array_1_1_iterator.html" title="Iterator for the array class that supports random access." alt="" coords="1004,1872,1143,2064"/>
<area shape="poly" title=" " alt="" coords="1142,1836,1124,1873,1119,1871,1138,1833"/>
<area shape="rect" href="classoriginal_1_1vector_1_1_iterator.html" title="Random access iterator implementation for vector." alt="" coords="1168,1872,1313,2064"/>
<area shape="poly" title=" " alt="" coords="1243,1839,1243,1872,1238,1872,1238,1839"/>
<area shape="rect" href="classoriginal_1_1double_direction_iterator.html" title="Abstract base class for double&#45;direction iterators." alt="" coords="1339,1872,1502,2064"/>
<area shape="poly" title=" " alt="" coords="1424,1828,1424,1872,1418,1872,1418,1828"/>
<area shape="rect" href="classoriginal_1_1single_direction_iterator.html" title="Abstract base class for single&#45;direction iterators." alt="" coords="1526,1893,1685,2043"/>
<area shape="poly" title=" " alt="" coords="1494,1759,1568,1892,1563,1895,1490,1762"/>
<area shape="rect" href="classoriginal_1_1chain_1_1_iterator.html" title="Bidirectional iterator implementation for chain." alt="" coords="1350,2112,1491,2304"/>
<area shape="poly" title=" " alt="" coords="1423,2079,1423,2112,1418,2112,1418,2079"/>
<area shape="rect" href="classoriginal_1_1forward_chain_1_1_iterator.html" title="Iterator for forwardChain, supports single&#45;direction traversal." alt="" coords="1522,2112,1690,2304"/>
<area shape="poly" title=" " alt="" coords="1608,2058,1608,2112,1603,2112,1603,2058"/>
<area shape="poly" title=" " alt="" coords="1171,1268,1094,1484,1089,1482,1166,1267"/>
<area shape="poly" title=" " alt="" coords="1203,1268,1222,1440,1217,1441,1197,1268"/>
<area shape="poly" title=" " alt="" coords="1211,1267,1235,1330,1252,1362,1272,1390,1290,1406,1309,1414,1328,1422,1348,1438,1361,1456,1357,1459,1344,1442,1325,1426,1307,1418,1288,1410,1268,1394,1247,1364,1230,1332,1206,1269"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for original::iterator&lt; TYPE &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classoriginal_1_1iterator__coll__graph.png" border="0" usemap="#aoriginal_1_1iterator_3_01_t_y_p_e_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aoriginal_1_1iterator_3_01_t_y_p_e_01_4_coll__map" id="aoriginal_1_1iterator_3_01_t_y_p_e_01_4_coll__map">
<area shape="rect" title="Base iterator interface that supports common operations for iteration." alt="" coords="185,640,293,960"/>
<area shape="rect" href="classoriginal_1_1printable.html" title="Base class providing polymorphic string conversion capabilities." alt="" coords="5,181,158,592"/>
<area shape="poly" title=" " alt="" coords="166,600,188,657,183,659,161,602"/>
<area shape="rect" href="classoriginal_1_1cloneable.html" title="Concrete cloneable class with custom cloning behavior." alt="" coords="182,341,296,432"/>
<area shape="poly" title=" " alt="" coords="242,447,242,640,236,640,236,447"/>
<area shape="rect" href="classoriginal_1_1base_cloneable.html" title=" " alt="" coords="166,5,312,133"/>
<area shape="poly" title=" " alt="" coords="242,148,242,342,236,342,236,148"/>
<area shape="rect" href="classoriginal_1_1comparable.html" title=" " alt="" coords="321,269,454,504"/>
<area shape="poly" title=" " alt="" coords="343,518,296,650,291,648,338,517"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91e4c8dbedaa948f83b75a146480f338" id="r_a91e4c8dbedaa948f83b75a146480f338"><td class="memItemLeft" align="right" valign="top">TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e4c8dbedaa948f83b75a146480f338">operator*</a> ()</td></tr>
<tr class="memdesc:a91e4c8dbedaa948f83b75a146480f338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the iterator to get the element.  <br /></td></tr>
<tr class="separator:a91e4c8dbedaa948f83b75a146480f338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992637e84368b0d7e247a87a25dcfd8a" id="r_a992637e84368b0d7e247a87a25dcfd8a"><td class="memItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a992637e84368b0d7e247a87a25dcfd8a">operator*</a> () const</td></tr>
<tr class="memdesc:a992637e84368b0d7e247a87a25dcfd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the iterator to get a copy of the element.  <br /></td></tr>
<tr class="separator:a992637e84368b0d7e247a87a25dcfd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e83d148927dc255f9c65a0aa2e232e" id="r_ab8e83d148927dc255f9c65a0aa2e232e"><td class="memItemLeft" align="right" valign="top"><a id="ab8e83d148927dc255f9c65a0aa2e232e" name="ab8e83d148927dc255f9c65a0aa2e232e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator++</b> () const</td></tr>
<tr class="memdesc:ab8e83d148927dc255f9c65a0aa2e232e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator forward by one position. <br /></td></tr>
<tr class="separator:ab8e83d148927dc255f9c65a0aa2e232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a02ed1fafce72df8ac33eec8c98c86b" id="r_a0a02ed1fafce72df8ac33eec8c98c86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a02ed1fafce72df8ac33eec8c98c86b">operator++</a> (int postfix) const</td></tr>
<tr class="memdesc:a0a02ed1fafce72df8ac33eec8c98c86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator forward by one position (postfix).  <br /></td></tr>
<tr class="separator:a0a02ed1fafce72df8ac33eec8c98c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e77bc8790a10d81a681ef05d0e88aee" id="r_a3e77bc8790a10d81a681ef05d0e88aee"><td class="memItemLeft" align="right" valign="top"><a id="a3e77bc8790a10d81a681ef05d0e88aee" name="a3e77bc8790a10d81a681ef05d0e88aee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator--</b> () const</td></tr>
<tr class="memdesc:a3e77bc8790a10d81a681ef05d0e88aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator backward by one position. <br /></td></tr>
<tr class="separator:a3e77bc8790a10d81a681ef05d0e88aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36146ec6350b582893921ce93c7924ad" id="r_a36146ec6350b582893921ce93c7924ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36146ec6350b582893921ce93c7924ad">operator--</a> (int postfix) const</td></tr>
<tr class="memdesc:a36146ec6350b582893921ce93c7924ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator backward by one position (postfix).  <br /></td></tr>
<tr class="separator:a36146ec6350b582893921ce93c7924ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5df73e291f03c33b6ffebaf3b2b34e5" id="r_af5df73e291f03c33b6ffebaf3b2b34e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5df73e291f03c33b6ffebaf3b2b34e5">operator+=</a> (<a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a> steps) const =0</td></tr>
<tr class="memdesc:af5df73e291f03c33b6ffebaf3b2b34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a number of steps to the current position of iterator.  <br /></td></tr>
<tr class="separator:af5df73e291f03c33b6ffebaf3b2b34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a116cd7151d7d3c33d05352d58e342e" id="r_a3a116cd7151d7d3c33d05352d58e342e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a116cd7151d7d3c33d05352d58e342e">operator-=</a> (<a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a> steps) const =0</td></tr>
<tr class="memdesc:a3a116cd7151d7d3c33d05352d58e342e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a number of steps from the current position of iterator.  <br /></td></tr>
<tr class="separator:a3a116cd7151d7d3c33d05352d58e342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95604290841a1dbe6c15dfb1f15a67a7" id="r_a95604290841a1dbe6c15dfb1f15a67a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95604290841a1dbe6c15dfb1f15a67a7">compareTo</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> &amp;other) const override</td></tr>
<tr class="memdesc:a95604290841a1dbe6c15dfb1f15a67a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two iterators to determine their relative positions.  <br /></td></tr>
<tr class="separator:a95604290841a1dbe6c15dfb1f15a67a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bb02e3daa580bddd28dd7a05474eec" id="r_a06bb02e3daa580bddd28dd7a05474eec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06bb02e3daa580bddd28dd7a05474eec">operator-</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> &amp;other) const =0</td></tr>
<tr class="memdesc:a06bb02e3daa580bddd28dd7a05474eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between this iterator and another iterator.  <br /></td></tr>
<tr class="separator:a06bb02e3daa580bddd28dd7a05474eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a53c6257fdceffe9cd25629e38ca9" id="r_ab99a53c6257fdceffe9cd25629e38ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1iterator.html">iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab99a53c6257fdceffe9cd25629e38ca9">clone</a> () const override=0</td></tr>
<tr class="memdesc:ab99a53c6257fdceffe9cd25629e38ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the iterator.  <br /></td></tr>
<tr class="separator:ab99a53c6257fdceffe9cd25629e38ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462d4431f9aa9abe581e974e997164cc" id="r_a462d4431f9aa9abe581e974e997164cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462d4431f9aa9abe581e974e997164cc">operator bool</a> () const</td></tr>
<tr class="memdesc:a462d4431f9aa9abe581e974e997164cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iterator is valid (i.e., points to a valid element).  <br /></td></tr>
<tr class="separator:a462d4431f9aa9abe581e974e997164cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47f344cc4739a4961dbc596bd7ee0cc" id="r_ab47f344cc4739a4961dbc596bd7ee0cc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab47f344cc4739a4961dbc596bd7ee0cc">hasNext</a> () const =0</td></tr>
<tr class="memdesc:ab47f344cc4739a4961dbc596bd7ee0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a next element.  <br /></td></tr>
<tr class="separator:ab47f344cc4739a4961dbc596bd7ee0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116d12b73ab2d049b61156b612f2d412" id="r_a116d12b73ab2d049b61156b612f2d412"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a116d12b73ab2d049b61156b612f2d412">hasPrev</a> () const =0</td></tr>
<tr class="memdesc:a116d12b73ab2d049b61156b612f2d412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there is a previous element.  <br /></td></tr>
<tr class="separator:a116d12b73ab2d049b61156b612f2d412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65baa49879bb4b29d0201d358874121d" id="r_a65baa49879bb4b29d0201d358874121d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65baa49879bb4b29d0201d358874121d">atPrev</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> *other) const =0</td></tr>
<tr class="memdesc:a65baa49879bb4b29d0201d358874121d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this iterator is positioned at the previous element.  <br /></td></tr>
<tr class="separator:a65baa49879bb4b29d0201d358874121d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec53e1b4c7c0204a111c17e875eecae" id="r_a5ec53e1b4c7c0204a111c17e875eecae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ec53e1b4c7c0204a111c17e875eecae">atNext</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> *other) const =0</td></tr>
<tr class="memdesc:a5ec53e1b4c7c0204a111c17e875eecae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this iterator is positioned at the next element.  <br /></td></tr>
<tr class="separator:a5ec53e1b4c7c0204a111c17e875eecae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13183cb9ff4406bcdfdec0707e5e4ebf" id="r_a13183cb9ff4406bcdfdec0707e5e4ebf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13183cb9ff4406bcdfdec0707e5e4ebf">atPrev</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:a13183cb9ff4406bcdfdec0707e5e4ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this iterator is positioned at the previous element.  <br /></td></tr>
<tr class="separator:a13183cb9ff4406bcdfdec0707e5e4ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74990b588d6825b7f9567b6b173aa0f" id="r_ae74990b588d6825b7f9567b6b173aa0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae74990b588d6825b7f9567b6b173aa0f">atNext</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:ae74990b588d6825b7f9567b6b173aa0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this iterator is positioned at the next element.  <br /></td></tr>
<tr class="separator:ae74990b588d6825b7f9567b6b173aa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0229bb1ce4ce588da14acca494abd153" id="r_a0229bb1ce4ce588da14acca494abd153"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0229bb1ce4ce588da14acca494abd153">next</a> () const =0</td></tr>
<tr class="memdesc:a0229bb1ce4ce588da14acca494abd153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator to the next element.  <br /></td></tr>
<tr class="separator:a0229bb1ce4ce588da14acca494abd153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa1c7c6134cfaddbe0ebcd356426ea4" id="r_a9aa1c7c6134cfaddbe0ebcd356426ea4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aa1c7c6134cfaddbe0ebcd356426ea4">prev</a> () const =0</td></tr>
<tr class="memdesc:a9aa1c7c6134cfaddbe0ebcd356426ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator to the previous element.  <br /></td></tr>
<tr class="separator:a9aa1c7c6134cfaddbe0ebcd356426ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee694bbe04f98f29d8cef46cf1a4a131" id="r_aee694bbe04f98f29d8cef46cf1a4a131"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoriginal_1_1iterator.html">iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee694bbe04f98f29d8cef46cf1a4a131">getNext</a> () const</td></tr>
<tr class="memdesc:aee694bbe04f98f29d8cef46cf1a4a131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new iterator pointing to the next element.  <br /></td></tr>
<tr class="separator:aee694bbe04f98f29d8cef46cf1a4a131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526892095639aa4ece2bca82442f9eaa" id="r_a526892095639aa4ece2bca82442f9eaa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoriginal_1_1iterator.html">iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a526892095639aa4ece2bca82442f9eaa">getPrev</a> () const =0</td></tr>
<tr class="memdesc:a526892095639aa4ece2bca82442f9eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new iterator pointing to the previous element.  <br /></td></tr>
<tr class="separator:a526892095639aa4ece2bca82442f9eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813e40c0ac1f69dab383a74e0dbf36d9" id="r_a813e40c0ac1f69dab383a74e0dbf36d9"><td class="memItemLeft" align="right" valign="top">virtual TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a813e40c0ac1f69dab383a74e0dbf36d9">get</a> ()=0</td></tr>
<tr class="memdesc:a813e40c0ac1f69dab383a74e0dbf36d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the element pointed to by the iterator.  <br /></td></tr>
<tr class="separator:a813e40c0ac1f69dab383a74e0dbf36d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21ae10d4024ddaa8fae45e1d79b14b3" id="r_ae21ae10d4024ddaa8fae45e1d79b14b3"><td class="memItemLeft" align="right" valign="top">virtual TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae21ae10d4024ddaa8fae45e1d79b14b3">get</a> () const =0</td></tr>
<tr class="memdesc:ae21ae10d4024ddaa8fae45e1d79b14b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a copy of the element pointed to by the iterator.  <br /></td></tr>
<tr class="separator:ae21ae10d4024ddaa8fae45e1d79b14b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecf969ca31e4c008ce47b029ba9b363" id="r_aeecf969ca31e4c008ce47b029ba9b363"><td class="memItemLeft" align="right" valign="top">virtual TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeecf969ca31e4c008ce47b029ba9b363">getElem</a> () const</td></tr>
<tr class="memdesc:aeecf969ca31e4c008ce47b029ba9b363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the element.  <br /></td></tr>
<tr class="separator:aeecf969ca31e4c008ce47b029ba9b363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca097831179d22512cbae55959e69cb" id="r_a4ca097831179d22512cbae55959e69cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ca097831179d22512cbae55959e69cb">set</a> (const TYPE &amp;data)=0</td></tr>
<tr class="memdesc:a4ca097831179d22512cbae55959e69cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element pointed to by the iterator.  <br /></td></tr>
<tr class="separator:a4ca097831179d22512cbae55959e69cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2765375f6ad5656e2b0543ef27b31e43" id="r_a2765375f6ad5656e2b0543ef27b31e43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2765375f6ad5656e2b0543ef27b31e43">equal</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> *other) const</td></tr>
<tr class="memdesc:a2765375f6ad5656e2b0543ef27b31e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two iterators are equal.  <br /></td></tr>
<tr class="separator:a2765375f6ad5656e2b0543ef27b31e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1ce8e86f3b98c54e7a141616652dba" id="r_abe1ce8e86f3b98c54e7a141616652dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe1ce8e86f3b98c54e7a141616652dba">equal</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:abe1ce8e86f3b98c54e7a141616652dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two iterators are equal.  <br /></td></tr>
<tr class="separator:abe1ce8e86f3b98c54e7a141616652dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bee5e665374006ce760fd8b7cbae6f" id="r_aa0bee5e665374006ce760fd8b7cbae6f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0bee5e665374006ce760fd8b7cbae6f">isValid</a> () const =0</td></tr>
<tr class="memdesc:aa0bee5e665374006ce760fd8b7cbae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the iterator is valid.  <br /></td></tr>
<tr class="separator:aa0bee5e665374006ce760fd8b7cbae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533f6b5736d2e99c9115024c5846225a" id="r_a533f6b5736d2e99c9115024c5846225a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a533f6b5736d2e99c9115024c5846225a">className</a> () const override</td></tr>
<tr class="memdesc:a533f6b5736d2e99c9115024c5846225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class name of the iterator.  <br /></td></tr>
<tr class="separator:a533f6b5736d2e99c9115024c5846225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bd687bfc25784c8d6b61425c066b4d" id="r_a45bd687bfc25784c8d6b61425c066b4d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45bd687bfc25784c8d6b61425c066b4d">toString</a> (bool enter) const override</td></tr>
<tr class="memdesc:a45bd687bfc25784c8d6b61425c066b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of the iterator.  <br /></td></tr>
<tr class="separator:a45bd687bfc25784c8d6b61425c066b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e40571a0b0571ce5e1b7ce30d43d1a" id="r_a23e40571a0b0571ce5e1b7ce30d43d1a"><td class="memItemLeft" align="right" valign="top"><a id="a23e40571a0b0571ce5e1b7ce30d43d1a" name="a23e40571a0b0571ce5e1b7ce30d43d1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~iterator</b> () override=default</td></tr>
<tr class="memdesc:a23e40571a0b0571ce5e1b7ce30d43d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for proper cleanup of derived objects. <br /></td></tr>
<tr class="separator:a23e40571a0b0571ce5e1b7ce30d43d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoriginal_1_1printable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classoriginal_1_1printable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoriginal_1_1printable.html">original::printable</a></td></tr>
<tr class="memitem:a25115aca8a3414062cac9d6027c9c525 inherit pub_methods_classoriginal_1_1printable" id="r_a25115aca8a3414062cac9d6027c9c525"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#a25115aca8a3414062cac9d6027c9c525">operator std::string</a> () const</td></tr>
<tr class="memdesc:a25115aca8a3414062cac9d6027c9c525 inherit pub_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion to std::string.  <br /></td></tr>
<tr class="separator:a25115aca8a3414062cac9d6027c9c525 inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90d2e1d35c97ccf92c283f1a7158da8 inherit pub_methods_classoriginal_1_1printable" id="r_ae90d2e1d35c97ccf92c283f1a7158da8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#ae90d2e1d35c97ccf92c283f1a7158da8">operator const char *</a> () const</td></tr>
<tr class="memdesc:ae90d2e1d35c97ccf92c283f1a7158da8 inherit pub_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit conversion to C-style string.  <br /></td></tr>
<tr class="separator:ae90d2e1d35c97ccf92c283f1a7158da8 inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177ad2994931423fe8b72b288e0238b inherit pub_methods_classoriginal_1_1printable" id="r_a0177ad2994931423fe8b72b288e0238b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#a0177ad2994931423fe8b72b288e0238b">toCString</a> (bool enter) const</td></tr>
<tr class="memdesc:a0177ad2994931423fe8b72b288e0238b inherit pub_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct C-string access with formatting control.  <br /></td></tr>
<tr class="separator:a0177ad2994931423fe8b72b288e0238b inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ac81d6329bcce8c4b9ca5290c7e18a inherit pub_methods_classoriginal_1_1printable" id="r_a61ac81d6329bcce8c4b9ca5290c7e18a"><td class="memTemplParams" colspan="2">
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a61ac81d6329bcce8c4b9ca5290c7e18a inherit pub_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatString</b> (const TYPE &amp;t) -&gt; std::string</td></tr>
<tr class="separator:a61ac81d6329bcce8c4b9ca5290c7e18a inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d31e5c0935ae75e77653f694ed88bb inherit pub_methods_classoriginal_1_1printable" id="r_a05d31e5c0935ae75e77653f694ed88bb"><td class="memTemplParams" colspan="2">
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a05d31e5c0935ae75e77653f694ed88bb inherit pub_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatCString</b> (const TYPE &amp;t) -&gt; const char *</td></tr>
<tr class="separator:a05d31e5c0935ae75e77653f694ed88bb inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83791824cca2a8773102bf62306eeb61 inherit pub_methods_classoriginal_1_1printable" id="r_a83791824cca2a8773102bf62306eeb61"><td class="memTemplParams" colspan="2">
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a83791824cca2a8773102bf62306eeb61 inherit pub_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatEnum</b> (const TYPE &amp;t) -&gt; std::string</td></tr>
<tr class="separator:a83791824cca2a8773102bf62306eeb61 inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610bc8db3b052e51aadaa6df803459a7 inherit pub_methods_classoriginal_1_1printable" id="r_a610bc8db3b052e51aadaa6df803459a7"><td class="memTemplParams" colspan="2">
template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a610bc8db3b052e51aadaa6df803459a7 inherit pub_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatString</b> (TYPE *const &amp;ptr) -&gt; std::string</td></tr>
<tr class="separator:a610bc8db3b052e51aadaa6df803459a7 inherit pub_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoriginal_1_1cloneable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classoriginal_1_1cloneable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoriginal_1_1cloneable.html">original::cloneable</a></td></tr>
<tr class="memitem:a773928dbbe382c8b92f958960abbb73a inherit pub_methods_classoriginal_1_1cloneable" id="r_a773928dbbe382c8b92f958960abbb73a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1cloneable.html#a773928dbbe382c8b92f958960abbb73a">~cloneable</a> () override=default</td></tr>
<tr class="memdesc:a773928dbbe382c8b92f958960abbb73a inherit pub_methods_classoriginal_1_1cloneable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for cloneable.  <br /></td></tr>
<tr class="separator:a773928dbbe382c8b92f958960abbb73a inherit pub_methods_classoriginal_1_1cloneable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoriginal_1_1base_cloneable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classoriginal_1_1base_cloneable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoriginal_1_1base_cloneable.html">original::baseCloneable&lt; cloneable &gt;</a></td></tr>
<tr class="memitem:a2bb3cf7e20bb9f7bb20e2a2fc351da8b inherit pub_methods_classoriginal_1_1base_cloneable" id="r_a2bb3cf7e20bb9f7bb20e2a2fc351da8b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1base_cloneable.html#a2bb3cf7e20bb9f7bb20e2a2fc351da8b">~baseCloneable</a> ()=default</td></tr>
<tr class="memdesc:a2bb3cf7e20bb9f7bb20e2a2fc351da8b inherit pub_methods_classoriginal_1_1base_cloneable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for <a class="el" href="classoriginal_1_1base_cloneable.html" title="Base class that defines a cloneable interface.">baseCloneable</a>.  <br /></td></tr>
<tr class="separator:a2bb3cf7e20bb9f7bb20e2a2fc351da8b inherit pub_methods_classoriginal_1_1base_cloneable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classoriginal_1_1comparable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classoriginal_1_1comparable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classoriginal_1_1comparable.html">original::comparable&lt; iterator&lt; TYPE &gt; &gt;</a></td></tr>
<tr class="memitem:a84244853f46e0ba1243e5707bfbf73bb inherit pub_methods_classoriginal_1_1comparable" id="r_a84244853f46e0ba1243e5707bfbf73bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html#a84244853f46e0ba1243e5707bfbf73bb">operator==</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;other) const</td></tr>
<tr class="memdesc:a84244853f46e0ba1243e5707bfbf73bb inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current object is equal to another.  <br /></td></tr>
<tr class="separator:a84244853f46e0ba1243e5707bfbf73bb inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1169a9b25fffa972dd5fa367ae7902fa inherit pub_methods_classoriginal_1_1comparable" id="r_a1169a9b25fffa972dd5fa367ae7902fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html#a1169a9b25fffa972dd5fa367ae7902fa">operator!=</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;other) const</td></tr>
<tr class="memdesc:a1169a9b25fffa972dd5fa367ae7902fa inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current object is not equal to another.  <br /></td></tr>
<tr class="separator:a1169a9b25fffa972dd5fa367ae7902fa inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83119b5b12ee88ecaa4036d4eb9739c inherit pub_methods_classoriginal_1_1comparable" id="r_ad83119b5b12ee88ecaa4036d4eb9739c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html#ad83119b5b12ee88ecaa4036d4eb9739c">operator&lt;</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;other) const</td></tr>
<tr class="memdesc:ad83119b5b12ee88ecaa4036d4eb9739c inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current object is less than another.  <br /></td></tr>
<tr class="separator:ad83119b5b12ee88ecaa4036d4eb9739c inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ab8c29bc8416a3068aac138a821b95 inherit pub_methods_classoriginal_1_1comparable" id="r_ad4ab8c29bc8416a3068aac138a821b95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html#ad4ab8c29bc8416a3068aac138a821b95">operator&gt;</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;other) const</td></tr>
<tr class="memdesc:ad4ab8c29bc8416a3068aac138a821b95 inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current object is greater than another.  <br /></td></tr>
<tr class="separator:ad4ab8c29bc8416a3068aac138a821b95 inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0888fb1bca62c77d10756a177f8e678e inherit pub_methods_classoriginal_1_1comparable" id="r_a0888fb1bca62c77d10756a177f8e678e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html#a0888fb1bca62c77d10756a177f8e678e">operator&lt;=</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;other) const</td></tr>
<tr class="memdesc:a0888fb1bca62c77d10756a177f8e678e inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current object is less than or equal to another.  <br /></td></tr>
<tr class="separator:a0888fb1bca62c77d10756a177f8e678e inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e05e7b5ee65cd29f3bb6be336de2c2 inherit pub_methods_classoriginal_1_1comparable" id="r_a28e05e7b5ee65cd29f3bb6be336de2c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html#a28e05e7b5ee65cd29f3bb6be336de2c2">operator&gt;=</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;other) const</td></tr>
<tr class="memdesc:a28e05e7b5ee65cd29f3bb6be336de2c2 inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current object is greater than or equal to another.  <br /></td></tr>
<tr class="separator:a28e05e7b5ee65cd29f3bb6be336de2c2 inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a2f94dd22d16e84f4b83a495b8a11d inherit pub_methods_classoriginal_1_1comparable" id="r_ad4a2f94dd22d16e84f4b83a495b8a11d"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~comparable</b> ()=default</td></tr>
<tr class="memdesc:ad4a2f94dd22d16e84f4b83a495b8a11d inherit pub_methods_classoriginal_1_1comparable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for proper cleanup of derived objects. <br /></td></tr>
<tr class="separator:ad4a2f94dd22d16e84f4b83a495b8a11d inherit pub_methods_classoriginal_1_1comparable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a098c98d026a535a28cf65514fb1e209b" id="r_a098c98d026a535a28cf65514fb1e209b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a098c98d026a535a28cf65514fb1e209b">equalPtr</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a> *other) const =0</td></tr>
<tr class="memdesc:a098c98d026a535a28cf65514fb1e209b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two iterators point to the same underlying element.  <br /></td></tr>
<tr class="separator:a098c98d026a535a28cf65514fb1e209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classoriginal_1_1cloneable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classoriginal_1_1cloneable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classoriginal_1_1cloneable.html">original::cloneable</a></td></tr>
<tr class="memitem:ab979c76e6fb5cd0aeb924e7afb1d3aa2 inherit pro_methods_classoriginal_1_1cloneable" id="r_ab979c76e6fb5cd0aeb924e7afb1d3aa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1cloneable.html#ab979c76e6fb5cd0aeb924e7afb1d3aa2">cloneable</a> ()=default</td></tr>
<tr class="memdesc:ab979c76e6fb5cd0aeb924e7afb1d3aa2 inherit pro_methods_classoriginal_1_1cloneable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for cloneable.  <br /></td></tr>
<tr class="separator:ab979c76e6fb5cd0aeb924e7afb1d3aa2 inherit pro_methods_classoriginal_1_1cloneable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classoriginal_1_1base_cloneable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_classoriginal_1_1base_cloneable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classoriginal_1_1base_cloneable.html">original::baseCloneable&lt; cloneable &gt;</a></td></tr>
<tr class="memitem:a60b88e43115c148ff4e52a53941dc316 inherit pro_methods_classoriginal_1_1base_cloneable" id="r_a60b88e43115c148ff4e52a53941dc316"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1base_cloneable.html#a60b88e43115c148ff4e52a53941dc316">baseCloneable</a> ()=default</td></tr>
<tr class="memdesc:a60b88e43115c148ff4e52a53941dc316 inherit pro_methods_classoriginal_1_1base_cloneable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for <a class="el" href="classoriginal_1_1base_cloneable.html" title="Base class that defines a cloneable interface.">baseCloneable</a>.  <br /></td></tr>
<tr class="separator:a60b88e43115c148ff4e52a53941dc316 inherit pro_methods_classoriginal_1_1base_cloneable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3f2bd41052ccf2a0266f1c03323dfcc0" id="r_a3f2bd41052ccf2a0266f1c03323dfcc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f2bd41052ccf2a0266f1c03323dfcc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f2bd41052ccf2a0266f1c03323dfcc0">operator+</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;it, <a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a> steps)</td></tr>
<tr class="memdesc:a3f2bd41052ccf2a0266f1c03323dfcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a number of steps to the iterator's current position and returns a new iterator.  <br /></td></tr>
<tr class="separator:a3f2bd41052ccf2a0266f1c03323dfcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b995c7bc03eae6217994040ac902cd" id="r_a93b995c7bc03eae6217994040ac902cd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93b995c7bc03eae6217994040ac902cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a93b995c7bc03eae6217994040ac902cd">operator-</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;it, <a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a> steps)</td></tr>
<tr class="memdesc:a93b995c7bc03eae6217994040ac902cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a number of steps from the iterator's current position and returns a new iterator.  <br /></td></tr>
<tr class="separator:a93b995c7bc03eae6217994040ac902cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28c23c51b7e407d719c5712329563e8" id="r_af28c23c51b7e407d719c5712329563e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af28c23c51b7e407d719c5712329563e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af28c23c51b7e407d719c5712329563e8">operator==</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;l_it, const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;r_it)</td></tr>
<tr class="memdesc:af28c23c51b7e407d719c5712329563e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for iterators.  <br /></td></tr>
<tr class="separator:af28c23c51b7e407d719c5712329563e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383f5420de2c22dee47e87f715027f50" id="r_a383f5420de2c22dee47e87f715027f50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a383f5420de2c22dee47e87f715027f50"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a383f5420de2c22dee47e87f715027f50">operator!=</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;l_it, const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;r_it)</td></tr>
<tr class="memdesc:a383f5420de2c22dee47e87f715027f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator for iterators.  <br /></td></tr>
<tr class="separator:a383f5420de2c22dee47e87f715027f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classoriginal_1_1printable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classoriginal_1_1printable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classoriginal_1_1printable.html">original::printable</a></td></tr>
<tr class="memitem:af9c95c33d1f0abc8188d2c594e879fb6 inherit pub_static_methods_classoriginal_1_1printable" id="r_af9c95c33d1f0abc8188d2c594e879fb6"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:af9c95c33d1f0abc8188d2c594e879fb6 inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#af9c95c33d1f0abc8188d2c594e879fb6">formatString</a> (const TYPE &amp;t)</td></tr>
<tr class="memdesc:af9c95c33d1f0abc8188d2c594e879fb6 inherit pub_static_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal value-to-string conversion.  <br /></td></tr>
<tr class="separator:af9c95c33d1f0abc8188d2c594e879fb6 inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf2a2858408f5bac18b5ef37e8def97 inherit pub_static_methods_classoriginal_1_1printable" id="r_a4bf2a2858408f5bac18b5ef37e8def97"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a4bf2a2858408f5bac18b5ef37e8def97 inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#a4bf2a2858408f5bac18b5ef37e8def97">formatString</a> (TYPE *const &amp;ptr)</td></tr>
<tr class="memdesc:a4bf2a2858408f5bac18b5ef37e8def97 inherit pub_static_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer-specific formatting.  <br /></td></tr>
<tr class="separator:a4bf2a2858408f5bac18b5ef37e8def97 inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add55e1dfceb5c3f8129f4288acb369ce inherit pub_static_methods_classoriginal_1_1printable" id="r_add55e1dfceb5c3f8129f4288acb369ce"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:add55e1dfceb5c3f8129f4288acb369ce inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#add55e1dfceb5c3f8129f4288acb369ce">formatCString</a> (const TYPE &amp;t)</td></tr>
<tr class="memdesc:add55e1dfceb5c3f8129f4288acb369ce inherit pub_static_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string cache for temporary usage.  <br /></td></tr>
<tr class="separator:add55e1dfceb5c3f8129f4288acb369ce inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae855a42c7ce42173f1821938d433d29f inherit pub_static_methods_classoriginal_1_1printable" id="r_ae855a42c7ce42173f1821938d433d29f"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:ae855a42c7ce42173f1821938d433d29f inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html#ae855a42c7ce42173f1821938d433d29f">formatEnum</a> (const TYPE &amp;t)</td></tr>
<tr class="memdesc:ae855a42c7ce42173f1821938d433d29f inherit pub_static_methods_classoriginal_1_1printable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum formatting utility.  <br /></td></tr>
<tr class="separator:ae855a42c7ce42173f1821938d433d29f inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4971c21e0456e6c575684837202b40 inherit pub_static_methods_classoriginal_1_1printable" id="r_a3c4971c21e0456e6c575684837202b40"><td class="memItemLeft" align="right" valign="top">
template&lt;&gt; </td></tr>
<tr class="memitem:a3c4971c21e0456e6c575684837202b40 inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatString</b> (const char &amp;t) -&gt; std::string</td></tr>
<tr class="separator:a3c4971c21e0456e6c575684837202b40 inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d8c4f3e7d803dbe900ce0b930aca5a inherit pub_static_methods_classoriginal_1_1printable" id="r_af6d8c4f3e7d803dbe900ce0b930aca5a"><td class="memItemLeft" align="right" valign="top">
template&lt;&gt; </td></tr>
<tr class="memitem:af6d8c4f3e7d803dbe900ce0b930aca5a inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatString</b> (const bool &amp;t) -&gt; std::string</td></tr>
<tr class="separator:af6d8c4f3e7d803dbe900ce0b930aca5a inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8d4ee5dff3d54effed318cbfb7bb8c inherit pub_static_methods_classoriginal_1_1printable" id="r_acf8d4ee5dff3d54effed318cbfb7bb8c"><td class="memItemLeft" align="right" valign="top">
template&lt;&gt; </td></tr>
<tr class="memitem:acf8d4ee5dff3d54effed318cbfb7bb8c inherit pub_static_methods_classoriginal_1_1printable"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>formatString</b> (const char *const &amp;ptr) -&gt; std::string</td></tr>
<tr class="separator:acf8d4ee5dff3d54effed318cbfb7bb8c inherit pub_static_methods_classoriginal_1_1printable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TYPE&gt;<br />
class original::iterator&lt; TYPE &gt;</div><p>Base iterator interface that supports common operations for iteration. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of elements the iterator traverses.</td></tr>
  </table>
  </dd>
</dl>
<p>This class provides common operations for iterators, including dereferencing, moving forward and backward, and comparing iterators. It also supports cloning, and printing elements.</p>
<p>Derived classes are expected to provide specific implementations for methods like <code><a class="el" href="#a0229bb1ce4ce588da14acca494abd153" title="Moves the iterator to the next element.">next()</a></code>, <code><a class="el" href="#a9aa1c7c6134cfaddbe0ebcd356426ea4" title="Moves the iterator to the previous element.">prev()</a></code>, <code><a class="el" href="#a813e40c0ac1f69dab383a74e0dbf36d9" title="Gets the element pointed to by the iterator.">get()</a></code>, and <code><a class="el" href="#a4ca097831179d22512cbae55959e69cb" title="Sets the element pointed to by the iterator.">set()</a></code>. These implementations define the behavior of the iterator in a particular container.</p>
<p>Equality comparisons (<code>==</code> and <code>!=</code>) are optimized to use the <code>equalPtr</code> method for constant-time comparison, while ordering comparisons (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) and distance calculations use the <code>compareTo</code> method which may have different time complexity depending on the container implementation. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ae74990b588d6825b7f9567b6b173aa0f" name="ae74990b588d6825b7f9567b6b173aa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74990b588d6825b7f9567b6b173aa0f">&#9670;&#160;</a></span>atNext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::atNext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if this iterator is positioned at the next element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this iterator is at the next position of the other, false otherwise. </dd></dl>

</div>
</div>
<a id="a5ec53e1b4c7c0204a111c17e875eecae" name="a5ec53e1b4c7c0204a111c17e875eecae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec53e1b4c7c0204a111c17e875eecae">&#9670;&#160;</a></span>atNext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::atNext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this iterator is positioned at the next element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this iterator is at the next position of the other, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1array_1_1_iterator.html#a6ff5c7cddc8a6f0c433879e4510e6ebe">original::array&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a40514cae5a87b90755a59e4eabe67714">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#ae22edfc3b95bcfd918a1fd4e890bdf60">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1chain_1_1_iterator.html#a5c48f11855d7d7387c05f916f7a8cb07">original::chain&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1forward_chain_1_1_iterator.html#af0f4d8c0cd1ae31a29f86bce68f8d8ba">original::forwardChain&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a2277ae5caa296094279d4cf809e3dbf1">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a53fe67e5696cebcf8b5033ecb165aa5f">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#aa76772042345b62a93c8dc956cebe2f3">original::stepIterator&lt; TYPE &gt;</a>, and <a class="el" href="classoriginal_1_1vector_1_1_iterator.html#a66dd5116c03ec59b5360c3631255bad3">original::vector&lt; TYPE, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a13183cb9ff4406bcdfdec0707e5e4ebf" name="a13183cb9ff4406bcdfdec0707e5e4ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13183cb9ff4406bcdfdec0707e5e4ebf">&#9670;&#160;</a></span>atPrev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::atPrev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if this iterator is positioned at the previous element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this iterator is at the previous position of the other, false otherwise. </dd></dl>

</div>
</div>
<a id="a65baa49879bb4b29d0201d358874121d" name="a65baa49879bb4b29d0201d358874121d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65baa49879bb4b29d0201d358874121d">&#9670;&#160;</a></span>atPrev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::atPrev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this iterator is positioned at the previous element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this iterator is at the previous position of the other, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1array_1_1_iterator.html#acdfe5d3426f81c0138ba5cb3a764f932">original::array&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a78f6222369a6500704176c39d6363db2">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#add9f0fb39e5107f60434a6db26237ff4">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1chain_1_1_iterator.html#ac4625f7235412b7df21932780281a227">original::chain&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1forward_chain_1_1_iterator.html#a35bae498a6227bc8bda4288c6e1b0017">original::forwardChain&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#ab4e5029c2655afe63188fea7304792a0">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#aea67df2dc35c5869f99ae747b43b18bb">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#af47d21b1a32f0e02531fb663bb9881fb">original::stepIterator&lt; TYPE &gt;</a>, and <a class="el" href="classoriginal_1_1vector_1_1_iterator.html#a6e5f8a14e4c144be56a183daad7f8b42">original::vector&lt; TYPE, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a533f6b5736d2e99c9115024c5846225a" name="a533f6b5736d2e99c9115024c5846225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533f6b5736d2e99c9115024c5846225a">&#9670;&#160;</a></span>className()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::className </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class name of the iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the class name. </dd></dl>

<p>Reimplemented from <a class="el" href="classoriginal_1_1printable.html#a964ede666275c3d0884df1c8a6e9f720">original::printable</a>.</p>

<p>Reimplemented in <a class="el" href="classoriginal_1_1random_access_iterator.html#a0a0faf28f4e97cfee333b4e0146d2d5f">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, and <a class="el" href="classoriginal_1_1step_iterator.html#a6fa4efa340b94b1dcfb1a3f315c54eb0">original::stepIterator&lt; TYPE &gt;</a>.</p>

</div>
</div>
<a id="ab99a53c6257fdceffe9cd25629e38ca9" name="ab99a53c6257fdceffe9cd25629e38ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99a53c6257fdceffe9cd25629e38ca9">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1iterator.html">iterator</a> * <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>A new copy of the iterator. </dd></dl>

<p>Reimplemented from <a class="el" href="classoriginal_1_1base_cloneable.html#abe3520c8dc2f0b77219b0ec620412b13">original::baseCloneable&lt; cloneable &gt;</a>.</p>

<p>Implemented in <a class="el" href="classoriginal_1_1array_1_1_iterator.html#ab0953e37d20999864c2b95796e73e529">original::array&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1base_iterator.html#a054415cd5c2f9b0648b3530250cab383">original::baseIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1base_iterator.html#a054415cd5c2f9b0648b3530250cab383">original::baseIterator&lt; bool &gt;</a>, <a class="el" href="classoriginal_1_1base_iterator.html#a054415cd5c2f9b0648b3530250cab383">original::baseIterator&lt; const TYPE &gt;</a>, <a class="el" href="classoriginal_1_1base_iterator.html#a054415cd5c2f9b0648b3530250cab383">original::baseIterator&lt; couple&lt; const K_TYPE, V_TYPE &gt; &gt;</a>, <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a641910c8d9da7759d68801e67527d585">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a0deb0b4ceb44095f23b5d46b1d2ac8ac">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1chain_1_1_iterator.html#a898141c68cf477ecd2b4ad6cfa9c4950">original::chain&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1double_direction_iterator.html#a2383e4b5fa9ee5ecc0b83118a4c2faea">original::doubleDirectionIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1forward_chain_1_1_iterator.html#a79ecaaf96152fdca54cacb12b5b0837d">original::forwardChain&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#aeb9585b602302336d40ac26e4f4ab058">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a7179bb1318652701e5ae4b546b684e15">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a3180a5d1f11acb2c7ffa2dca62916648">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#ad864a88500bbcfd55e69d50accf9a084">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1single_direction_iterator.html#a274fd315bab928d5d5bb80cd93473c43">original::singleDirectionIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a34c74f9915801bdb6bb022317bb7a581">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a7be46dcd7d079cf81cb9ae2513967be7">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#ac96e4cd0fb21bd47988b941bf14e58eb">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1vector_1_1_iterator.html#a0efdff463b1c005b645ffbd859586f89">original::vector&lt; TYPE, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a95604290841a1dbe6c15dfb1f15a67a7" name="a95604290841a1dbe6c15dfb1f15a67a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95604290841a1dbe6c15dfb1f15a67a7">&#9670;&#160;</a></span>compareTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::compareTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two iterators to determine their relative positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative value if this iterator is before the other, zero if at the same position, and a positive value if after the other.</dd></dl>
<p>This method provides ordering comparison between iterators, typically by calculating the distance between positions. Used by comparison operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) and three-way comparison (<code>&lt;=&gt;</code>).</p>
<p>Note this may be more expensive than pointer equality checks (equalPtr), as it may need to compute relative distances in the container.</p>
<dl class="section note"><dt>Note</dt><dd>For simple equality checks, prefer using equalPtr via operator==/!= instead. </dd></dl>

<p>Implements <a class="el" href="classoriginal_1_1comparable.html#a2d23e08b034cda29c2854121f3e700d7">original::comparable&lt; iterator&lt; TYPE &gt; &gt;</a>.</p>

</div>
</div>
<a id="abe1ce8e86f3b98c54e7a141616652dba" name="abe1ce8e86f3b98c54e7a141616652dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe1ce8e86f3b98c54e7a141616652dba">&#9670;&#160;</a></span>equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two iterators are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a2765375f6ad5656e2b0543ef27b31e43" name="a2765375f6ad5656e2b0543ef27b31e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2765375f6ad5656e2b0543ef27b31e43">&#9670;&#160;</a></span>equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two iterators are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators are equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a098c98d026a535a28cf65514fb1e209b" name="a098c98d026a535a28cf65514fb1e209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098c98d026a535a28cf65514fb1e209b">&#9670;&#160;</a></span>equalPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::equalPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two iterators point to the same underlying element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators point to the same object, false otherwise.</dd></dl>
<p>This method provides an optimized way to check iterator equality by comparing their underlying pointers or positions directly. It is used by the equality operators (<code>==</code> and <code>!=</code>) to provide constant-time comparison. Derived classes must implement this to compare their internal representation directly for optimal performance.</p>
<dl class="section note"><dt>Note</dt><dd>This should be a lightweight comparison that doesn't involve distance calculations or complex logic. For ordering comparisons, use <code>compareTo</code> instead. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a93f2bf296872b133f8e89ea4ac6ac2c0">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a2d02bd9d9f5a224ef0c549334e14eefa">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, and <a class="el" href="classoriginal_1_1step_iterator.html#a5d0e1c67b6f6f349765d2b520d864198">original::stepIterator&lt; TYPE &gt;</a>.</p>

</div>
</div>
<a id="ae21ae10d4024ddaa8fae45e1d79b14b3" name="ae21ae10d4024ddaa8fae45e1d79b14b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21ae10d4024ddaa8fae45e1d79b14b3">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TYPE <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a copy of the element pointed to by the iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the element. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a9290e37219a766964ab6f01798a5ffe2">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a57244074d2dc86ca45839533a746fa11">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#ad4602248dab665bafd7587f7b886e7fa">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a11c8db5720f7b83abe6fdafa30d82ede">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#ae231301bc8658b8010a050db8b391648">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a38d5ca04bafaa08675e055d688abe21a">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#ae042dd0cf34f0b64785d88bfb0086375">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a067e447bd24596addc19dbadbf45808b">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a63904484c8f6d3af9d223b9999f78c74">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a813e40c0ac1f69dab383a74e0dbf36d9" name="a813e40c0ac1f69dab383a74e0dbf36d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813e40c0ac1f69dab383a74e0dbf36d9">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TYPE &amp; <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::get </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the element pointed to by the iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a5beced1655cfd9f74383de8b9fff0387">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#ac8a3a36bd5b98a11591fd4f074b4a021">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#aece961c9fa00d31ee7b184b36afc4d39">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#add4ffb3313cb7af626aa3290478a7301">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a1871539012c808b85aa962c1b87901ea">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#aebbe2ce9740adf2ab67952bfc57dfabf">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a71d613af72e961651ebb0656cae523ee">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a03533635604f637ce94a72eb21e24557">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a340efd4d45df4224d712aeef857e2a12">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="aeecf969ca31e4c008ce47b029ba9b363" name="aeecf969ca31e4c008ce47b029ba9b363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecf969ca31e4c008ce47b029ba9b363">&#9670;&#160;</a></span>getElem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::getElem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the element. </dd></dl>

</div>
</div>
<a id="aee694bbe04f98f29d8cef46cf1a4a131" name="aee694bbe04f98f29d8cef46cf1a4a131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee694bbe04f98f29d8cef46cf1a4a131">&#9670;&#160;</a></span>getNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::getNext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new iterator pointing to the next element. </p>
<dl class="section return"><dt>Returns</dt><dd>A new iterator pointing to the next element. </dd></dl>

<p>Reimplemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#adcd0f865c7f55e177d35c39978b0479f">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a052d3bd443fa2494f43ebf3279f96191">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a919f0c7359ee83653327571a300e6fdd">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a02f11fc29613ec9e0c7ff0b6d8e91254">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, and <a class="el" href="classoriginal_1_1step_iterator.html#ae88b6682d19abe342a0eb64dcf6767a5">original::stepIterator&lt; TYPE &gt;</a>.</p>

</div>
</div>
<a id="a526892095639aa4ece2bca82442f9eaa" name="a526892095639aa4ece2bca82442f9eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526892095639aa4ece2bca82442f9eaa">&#9670;&#160;</a></span>getPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoriginal_1_1iterator.html">iterator</a> * <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::getPrev </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new iterator pointing to the previous element. </p>
<dl class="section return"><dt>Returns</dt><dd>A new iterator pointing to the previous element. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a22ddf22684f8b0290d261eb41b7427ce">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a901a39425242c7497c3d877dfe1a825f">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#a533e3119e6d7a9748e05e7d18bf76d74">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#aad46c513dec806385e15714b7d7db79f">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a3b77220e74c10213e9c48c6a84ba0ea4">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#ad64f306a73a632be931e5a8c156f0f06">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a0e35b2af2df817297aab12833f480188">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a75ac2a115ee711fe2a839372210c4931">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a9ad7f02a9d8354b14944b688419e9ea9">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="ab47f344cc4739a4961dbc596bd7ee0cc" name="ab47f344cc4739a4961dbc596bd7ee0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47f344cc4739a4961dbc596bd7ee0cc">&#9670;&#160;</a></span>hasNext()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::hasNext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is a next element. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there is a next element, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a22353359ca6b6516229100964e909ccb">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a6af05a26196bc371c8ee73ceeda8ff1f">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#a5b56c4086cd12bf8720f32626a111e78">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a3442638203350a96b71ad75a81a0173d">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#ac9270676fcb9ef390b2a53620ed22871">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a2ad6207b471965df3f934e7498616376">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#ab605b00b52d30806256cbe3ce6d3bb66">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a2367b37e4420b3e3fa73f2d0fa04a364">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a86c16e7ffb4c99a257a21fd61ef8832b">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a116d12b73ab2d049b61156b612f2d412" name="a116d12b73ab2d049b61156b612f2d412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116d12b73ab2d049b61156b612f2d412">&#9670;&#160;</a></span>hasPrev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::hasPrev </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if there is a previous element. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there is a previous element, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a00dbebdfb317fed5b70b1d2bd9341f66">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a9ff69d1923f44adee547e8be557559b6">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1double_direction_iterator.html#a7f4af58a043408005ef847e31ce50da8">original::doubleDirectionIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#af87d81420df119230c3330d2607324f2">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a8a44024491cea8a413026b99e6128e9c">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a6878d26b06e7f1a44c8793b4c4f29ae0">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a49e783c74c12d5e05cdfab6bff812efd">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a52ee8b8afce8d37d5db12c5cd51048f5">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#aeccce71877ef20f927ca56b652bb6078">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a97e18788f2b6a5d34b0cb03c3a82516e">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="aa0bee5e665374006ce760fd8b7cbae6f" name="aa0bee5e665374006ce760fd8b7cbae6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bee5e665374006ce760fd8b7cbae6f">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the iterator is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iterator is valid, false otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#ad9eaa5a4f4f8c7075515131182dcefc6">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#ad923e1d826b19a25df61ab124b52b310">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#aaee5b7e37067abc66a089683e9e2c770">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#ac1b5db6fd1d2e165d04549900f104da8">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#aafb13fdc6f8b1200316796f129b51d51">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#af77077998d66333052fd703de7704488">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#adb52e5702ee1bc2589eef25e822f3f50">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a7f0e5880d38176d54745a416a5df8265">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a057b43fb0dd5e2a0ea8c292ded4f3fba">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a0229bb1ce4ce588da14acca494abd153" name="a0229bb1ce4ce588da14acca494abd153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0229bb1ce4ce588da14acca494abd153">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::next </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the iterator to the next element. </p>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a62ba6bb25d0cb0d7beb9918f8df83f77">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a99ebfe18db84936e334c9337a025af99">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#a1b89aac61d4ef3242ec78959944e8c73">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a6274a3ab04dc6bd300a39492ede51499">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a962b3db7ea559fa8cfc2ed316cc92958">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#ab827df00af0f04f896712d9894d89f54">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a6f0b06b794d805cb8ac68a4f884cdf23">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a27157afcbab5e2907e9d5ca8e1402a87">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a1d5db52a24c0d80b7526c6a6dd92ad1a">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a462d4431f9aa9abe581e974e997164cc" name="a462d4431f9aa9abe581e974e997164cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462d4431f9aa9abe581e974e997164cc">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the iterator is valid (i.e., points to a valid element). </p>
<dl class="section return"><dt>Returns</dt><dd>True if the iterator is valid, false otherwise. </dd></dl>

</div>
</div>
<a id="a91e4c8dbedaa948f83b75a146480f338" name="a91e4c8dbedaa948f83b75a146480f338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e4c8dbedaa948f83b75a146480f338">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereferences the iterator to get the element. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element pointed to by the iterator. </dd></dl>

</div>
</div>
<a id="a992637e84368b0d7e247a87a25dcfd8a" name="a992637e84368b0d7e247a87a25dcfd8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992637e84368b0d7e247a87a25dcfd8a">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereferences the iterator to get a copy of the element. </p>
<dl class="section return"><dt>Returns</dt><dd>A copy of the element pointed to by the iterator. </dd></dl>

</div>
</div>
<a id="a0a02ed1fafce72df8ac33eec8c98c86b" name="a0a02ed1fafce72df8ac33eec8c98c86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a02ed1fafce72df8ac33eec8c98c86b">&#9670;&#160;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>postfix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the iterator forward by one position (postfix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">postfix</td><td>Unused parameter for postfix syntax. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5df73e291f03c33b6ffebaf3b2b34e5" name="af5df73e291f03c33b6ffebaf3b2b34e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5df73e291f03c33b6ffebaf3b2b34e5">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a number of steps to the current position of iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>The number of steps to move forward. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a8d9847fcaba4c8838787ecafb1de91e2">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#aa7ad34eda859e6d60b1b5cfba8d7cd31">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#aa59e409d0b24869397be41bfcae3e689">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#afc6c8ad43f5acf05125ef038955041b8">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a76d6fadc6b74ecf290af79735de624a9">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a8aa25c8cbe4a08704bda42ba446c2346">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#acef6b1c58e6d3bf5ccf60b05682cad3e">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#abd6527ae028075af9da94f559c7d56c3">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a620be8f52619a599e943868e66bd3c7b">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a06bb02e3daa580bddd28dd7a05474eec" name="a06bb02e3daa580bddd28dd7a05474eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bb02e3daa580bddd28dd7a05474eec">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a> <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the distance between this iterator and another iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The iterator to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of steps between the two iterators. Positive if this iterator is after the other, negative if before, zero if at same position.</dd></dl>
<p>This is the fundamental operation for iterator ordering comparisons. Used by <a class="el" href="#a95604290841a1dbe6c15dfb1f15a67a7" title="Compares two iterators to determine their relative positions.">compareTo()</a> to implement relational operators.</p>
<p>Time complexity depends on container type:</p><ul>
<li>O(1) for random-access iterators</li>
<li>O(n) for forward/bidirectional iterators</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>For equality comparison only, operator==/!= using equalPtr is more efficient. </dd></dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#a9cce30910ad2b1fcccb7316cba3cb3db">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#af3899af3d78557ea78157059d53ca8a9">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a5856e59f22ccd0c4546f8cb09b672970">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a221022c28711bcb023be578013276f93">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, and <a class="el" href="classoriginal_1_1step_iterator.html#a67329058ad4519df8f10f7156eb407a4">original::stepIterator&lt; TYPE &gt;</a>.</p>

</div>
</div>
<a id="a36146ec6350b582893921ce93c7924ad" name="a36146ec6350b582893921ce93c7924ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36146ec6350b582893921ce93c7924ad">&#9670;&#160;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator-- </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>postfix</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the iterator backward by one position (postfix). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">postfix</td><td>Unused parameter for postfix syntax. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a116cd7151d7d3c33d05352d58e342e" name="a3a116cd7151d7d3c33d05352d58e342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a116cd7151d7d3c33d05352d58e342e">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a number of steps from the current position of iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>The number of steps to move backward. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#aa4b60fcfda7af19c1b4d33d4e3acc8b9">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a387eb70b66230653e405e5ab1e731ff0">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#aaa295f5f7168157ef16b235e6dbfad0a">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a4d25e7d3f5e3f4c60738077c94af81d3">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a21ccf415edc087becc816813d4b02791">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#ae017eed40b590d0282b214e50500e241">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#af7e37ed1335a0af181d736db7b815181">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a6d7b53e1d93c08c6ef2328dd9bba380d">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a27f8b88b6ef9333d7c265a342bd0d050">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a9aa1c7c6134cfaddbe0ebcd356426ea4" name="a9aa1c7c6134cfaddbe0ebcd356426ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa1c7c6134cfaddbe0ebcd356426ea4">&#9670;&#160;</a></span>prev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::prev </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the iterator to the previous element. </p>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#ad81e1177bbd4a9b1e88ac98d568b03b1">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#a59aaeb227fc37c41ca8c3f0b09e8a79a">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1double_direction_iterator.html#ad60912351f0ad305e37a7902aa37d78f">original::doubleDirectionIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#a8a4f0850b098e2db5f23dc958d812623">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#af0d71413ce2a49cad671cc69e28306c8">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a7047c56b1d2b94f71a055b42a6e874e1">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a5b19c9feb4a49d49ef1c0bdbbe02e598">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a7d52e13bc2b2f79b8164e8b0cb5f4efa">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#a94a4d3e87ff108f2c04d83a721527a80">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a6d2aaea6b3d8188a2f9ae9b33175d86b">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a4ca097831179d22512cbae55959e69cb" name="a4ca097831179d22512cbae55959e69cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca097831179d22512cbae55959e69cb">&#9670;&#160;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const TYPE &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the element pointed to by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The new value to set. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classoriginal_1_1bit_set_1_1_iterator.html#ace3e81c346d4de141a08589577c6fe5b">original::bitSet&lt; ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1blocks_list_1_1_iterator.html#aaa5fde58e00402d66b20ff0b7dec5b81">original::blocksList&lt; TYPE, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_map_1_1_iterator.html#abba02caae1e3778d1fa7e63f2d8f6e93">original::hashMap&lt; K_TYPE, V_TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1hash_set_1_1_iterator.html#a926b30b44d0fc4258a4fc1fc1ec47e53">original::hashSet&lt; TYPE, HASH, ALLOC &gt;::Iterator</a>, <a class="el" href="classoriginal_1_1iterable_1_1iter_adaptor.html#a51779d1290a5c0b668c8ccaef9fc363a">original::iterable&lt; TYPE &gt;::iterAdaptor</a>, <a class="el" href="classoriginal_1_1random_access_iterator.html#a2b0d1846b114143705e94b7447f5a7f4">original::randomAccessIterator&lt; TYPE, ALLOC &gt;</a>, <a class="el" href="classoriginal_1_1step_iterator.html#a545756198391c96f8636ed497b99c25e">original::stepIterator&lt; TYPE &gt;</a>, <a class="el" href="classoriginal_1_1tree_map_1_1_iterator.html#aff1468db9e90cd1b0be470c09b4cfec6">original::treeMap&lt; K_TYPE, V_TYPE, Compare, ALLOC &gt;::Iterator</a>, and <a class="el" href="classoriginal_1_1tree_set_1_1_iterator.html#a5525480b6c18e2b5194c8aefaba81bf7">original::treeSet&lt; TYPE, Compare, ALLOC &gt;::Iterator</a>.</p>

</div>
</div>
<a id="a45bd687bfc25784c8d6b61425c066b4d" name="a45bd687bfc25784c8d6b61425c066b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bd687bfc25784c8d6b61425c066b4d">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1iterator.html">original::iterator</a>&lt; TYPE &gt;::toString </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enter</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a string representation of the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enter</td><td>If true, adds a newline after the string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representing the iterator. </dd></dl>

<p>Reimplemented from <a class="el" href="classoriginal_1_1printable.html#a8c944ccaa4e8cf8d6c8e9ac25471fe7e">original::printable</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a383f5420de2c22dee47e87f715027f50" name="a383f5420de2c22dee47e87f715027f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383f5420de2c22dee47e87f715027f50">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoriginal.html#a1fb35d1af29a0c0be3a17081b9ca9dd0">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>r_it</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison operator for iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements the iterator traverses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_it</td><td>Left-hand side iterator. </td></tr>
    <tr><td class="paramname">r_it</td><td>Right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators point to different elements, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation uses <code>equalPtr</code> for optimal constant-time comparison. </dd></dl>

</div>
</div>
<a id="a3f2bd41052ccf2a0266f1c03323dfcc0" name="a3f2bd41052ccf2a0266f1c03323dfcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2bd41052ccf2a0266f1c03323dfcc0">&#9670;&#160;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; * operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a number of steps to the iterator's current position and returns a new iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements the iterator will traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to move. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to move forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that is moved forward by the specified steps from the original iterator.</dd></dl>
<p>This operator does not modify the original iterator, but creates a new one that is advanced by <code>steps</code> positions. </p>

</div>
</div>
<a id="a93b995c7bc03eae6217994040ac902cd" name="a93b995c7bc03eae6217994040ac902cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b995c7bc03eae6217994040ac902cd">&#9670;&#160;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; * operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoriginal.html#a583969b2c4869f07ee4fedb102e587cd">integer</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts a number of steps from the iterator's current position and returns a new iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements the iterator will traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to move. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to move backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that is moved backward by the specified steps from the original iterator.</dd></dl>
<p>This operator does not modify the original iterator, but creates a new one that is moved backward by <code>steps</code> positions. </p>

</div>
</div>
<a id="af28c23c51b7e407d719c5712329563e8" name="af28c23c51b7e407d719c5712329563e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28c23c51b7e407d719c5712329563e8">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>l_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>r_it</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison operator for iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements the iterator traverses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_it</td><td>Left-hand side iterator. </td></tr>
    <tr><td class="paramname">r_it</td><td>Right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators point to the same element, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation uses <code>equalPtr</code> for optimal constant-time comparison. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/<a class="el" href="iterator_8h_source.html">iterator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
