<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ORIGINAL: original Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ORIGINAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">original Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace for the project Original.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1absTransform.html">absTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that converts an element to its absolute value.  <a href="classoriginal_1_1absTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1addOptTransform.html">addOptTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that adds a given value to an element.  <a href="classoriginal_1_1addOptTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1algorithms.html">algorithms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class containing generic container algorithms.  <a href="classoriginal_1_1algorithms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocateError.html">allocateError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for memory allocation failures.  <a href="classoriginal_1_1allocateError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocator.html">allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default memory allocator using allocators utilities.  <a href="classoriginal_1_1allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocatorBase.html">allocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for other memory allocator implements.  <a href="classoriginal_1_1allocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocators.html">allocators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class providing static memory allocation/de-allocation functions.  <a href="classoriginal_1_1allocators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size array container with random access.  <a href="classoriginal_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1assignOptTransform.html">assignOptTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that assigns a specified value to an element.  <a href="classoriginal_1_1assignOptTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base smart pointer with reference counting.  <a href="classoriginal_1_1autoPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseArray.html">baseArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for fixed-size serial containers.  <a href="classoriginal_1_1baseArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseCloneable.html">baseCloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class that defines a cloneable interface.  <a href="classoriginal_1_1baseCloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseIterator.html">baseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for basic iterators.  <a href="classoriginal_1_1baseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseList.html">baseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for variable-size serial containers.  <a href="classoriginal_1_1baseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a set of bits, offering functionality to manipulate and query individual bits.  <a href="classoriginal_1_1bitSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1blocksList.html">blocksList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-based list implementation.  <a href="classoriginal_1_1blocksList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1callBackChecker.html">callBackChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static utility for validating callback signatures.  <a href="classoriginal_1_1callBackChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1callbackReturnTypeError.html">callbackReturnTypeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for callback return type mismatch.  <a href="classoriginal_1_1callbackReturnTypeError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1callbackSignatureError.html">callbackSignatureError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for callback argument mismatch.  <a href="classoriginal_1_1callbackSignatureError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1chain.html">chain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cyclic doubly linked list container.  <a href="classoriginal_1_1chain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1cloneable.html">cloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete cloneable class with custom cloning behavior.  <a href="classoriginal_1_1cloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html">comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for comparable objects.  <a href="classoriginal_1_1comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparator.html">comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for comparison.  <a href="classoriginal_1_1comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1container.html">container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for containers.  <a href="classoriginal_1_1container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1containerAdapter.html">containerAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter class that provides unified interface for various container types.  <a href="classoriginal_1_1containerAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1copyTransform.html">copyTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that copies an element into a container.  <a href="classoriginal_1_1copyTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1couple.html">couple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for two heterogeneous elements.  <a href="classoriginal_1_1couple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1decreaseComparator.html">decreaseComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for decreasing comparison (greater than).  <a href="classoriginal_1_1decreaseComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1decreaseNotStrictComparator.html">decreaseNotStrictComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for non-strict decreasing comparison (greater than or equal to).  <a href="classoriginal_1_1decreaseNotStrictComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleter.html">deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default deletion policy for single objects.  <a href="classoriginal_1_1deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleter_3_01TYPE_0f_0e_4.html">deleter&lt; TYPE[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleterBase.html">deleterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for deleters defining the deletion policy interface.  <a href="classoriginal_1_1deleterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleterBase_3_01TYPE_0f_0e_4.html">deleterBase&lt; TYPE[]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for array deleters.  <a href="classoriginal_1_1deleterBase_3_01TYPE_0f_0e_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deque.html">deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-ended queue container adapter.  <a href="classoriginal_1_1deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1doubleDirectionIterator.html">doubleDirectionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for double-direction iterators.  <a href="classoriginal_1_1doubleDirectionIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1equalComparator.html">equalComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for equality comparison.  <a href="classoriginal_1_1equalComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1equalFilter.html">equalFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is equal to a target value.  <a href="classoriginal_1_1equalFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1error.html">error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base interface for all exception types in Original.  <a href="classoriginal_1_1error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1filter.html">filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for filter operations.  <a href="classoriginal_1_1filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite filter builder with logical operator chaining.  <a href="classoriginal_1_1filterStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1forwardChain.html">forwardChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singly linked list implementation.  <a href="classoriginal_1_1forwardChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1greaterFilter.html">greaterFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is greater than a target value.  <a href="classoriginal_1_1greaterFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1increaseComparator.html">increaseComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for increasing comparison (less than).  <a href="classoriginal_1_1increaseComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1increaseNotStrictComparator.html">increaseNotStrictComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for non-strict increasing comparison (less than or equal to).  <a href="classoriginal_1_1increaseNotStrictComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1iterable.html">iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for iterable containers that support iterators.  <a href="classoriginal_1_1iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1iterationStream.html">iterationStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream class that allows iteration, comparison, and printing.  <a href="classoriginal_1_1iterationStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base iterator interface that supports common operations for iteration.  <a href="classoriginal_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1lessFilter.html">lessFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is less than a target value.  <a href="classoriginal_1_1lessFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1multiOptTransform.html">multiOptTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that multiplies an element by a given value.  <a href="classoriginal_1_1multiOptTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1noElementError.html">noElementError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for missing element requests.  <a href="classoriginal_1_1noElementError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notEqualComparator.html">notEqualComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for inequality comparison.  <a href="classoriginal_1_1notEqualComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notEqualFilter.html">notEqualFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is not equal to a target value.  <a href="classoriginal_1_1notEqualFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notGreaterFilter.html">notGreaterFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is less than or equal to a target value.  <a href="classoriginal_1_1notGreaterFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notLessFilter.html">notLessFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is greater than or equal to a target value.  <a href="classoriginal_1_1notLessFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1nullPointerError.html">nullPointerError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for null pointer dereference attempts.  <a href="classoriginal_1_1nullPointerError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1objPoolAllocator.html">objPoolAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool allocator for efficient fixed-size memory management.  <a href="classoriginal_1_1objPoolAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1outOfBoundError.html">outOfBoundError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for container index out-of-range errors.  <a href="classoriginal_1_1outOfBoundError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique ownership smart pointer with move semantics.  <a href="classoriginal_1_1ownerPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html">printable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing polymorphic string conversion capabilities.  <a href="classoriginal_1_1printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1prique.html">prique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap-based priority queue container.  <a href="classoriginal_1_1prique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1queue.html">queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">First-In-First-Out (FIFO) container adapter.  <a href="classoriginal_1_1queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1randomAccessIterator.html">randomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for random-access iterators.  <a href="classoriginal_1_1randomAccessIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1rangeFilter.html">rangeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element lies within a specified range.  <a href="classoriginal_1_1rangeFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1refCntPtr.html">refCntPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference-counted pointers.  <a href="classoriginal_1_1refCntPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1refCount.html">refCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting metadata container.  <a href="classoriginal_1_1refCount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1serial.html">serial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for sequential containers with index-based access.  <a href="classoriginal_1_1serial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1singleDirectionIterator.html">singleDirectionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for single-direction iterators.  <a href="classoriginal_1_1singleDirectionIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last-In-First-Out (LIFO) container adapter.  <a href="classoriginal_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError.html">staticError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time error assertion utility.  <a href="classoriginal_1_1staticError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1allocateError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::allocateError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1callbackReturnTypeError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::callbackReturnTypeError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1callbackSignatureError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::callbackSignatureError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1error_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::error, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1noElementError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::noElementError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1nullPointerError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::nullPointerError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1outOfBoundError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::outOfBoundError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1unSupportedMethodError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::unSupportedMethodError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1valueError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::valueError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1stepIterator.html">stepIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for step iterators.  <a href="classoriginal_1_1stepIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership smart pointer with strong references.  <a href="classoriginal_1_1strongPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1transform.html">transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for transformation operations.  <a href="classoriginal_1_1transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered sequence of transformation operations.  <a href="classoriginal_1_1transformStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size heterogeneous container that stores elements of different types.  <a href="classoriginal_1_1tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1unSupportedMethodError.html">unSupportedMethodError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for unimplemented method calls.  <a href="classoriginal_1_1unSupportedMethodError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1valueError.html">valueError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for invalid parameter values.  <a href="classoriginal_1_1valueError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array container with amortized constant time operations.  <a href="classoriginal_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1weakPtr.html">weakPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning reference to shared resource.  <a href="classoriginal_1_1weakPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1wrapper.html">wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for linked value containers with formatted output.  <a href="classoriginal_1_1wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Comparable.html">Comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support all comparison operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1CallbackOf.html">CallbackOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates callback signature compatibility. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Compare.html">Compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines Comparable and CallbackOf for comparison callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Condition.html">Condition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint for predicate callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint for mutating operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1SuperOf.html">SuperOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks inheritance or type equality. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1ExtendsOf.html">ExtendsOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks derivation or type identity. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a583969b2c4869f07ee4fedb102e587cd" id="r_a583969b2c4869f07ee4fedb102e587cd"><td class="memItemLeft" align="right" valign="top"><a id="a583969b2c4869f07ee4fedb102e587cd" name="a583969b2c4869f07ee4fedb102e587cd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>integer</b> = std::int64_t</td></tr>
<tr class="memdesc:a583969b2c4869f07ee4fedb102e587cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type for arithmetic operations <br /></td></tr>
<tr class="separator:a583969b2c4869f07ee4fedb102e587cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d678ae654034cea391c946ada41bd2e" id="r_a2d678ae654034cea391c946ada41bd2e"><td class="memItemLeft" align="right" valign="top"><a id="a2d678ae654034cea391c946ada41bd2e" name="a2d678ae654034cea391c946ada41bd2e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>u_integer</b> = std::uint32_t</td></tr>
<tr class="memdesc:a2d678ae654034cea391c946ada41bd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type for sizes/indexes <br /></td></tr>
<tr class="separator:a2d678ae654034cea391c946ada41bd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8dc21f8c884d90b6204bcd6890033aa6" id="r_a8dc21f8c884d90b6204bcd6890033aa6"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DER, typename DEL&gt; </td></tr>
<tr class="memitem:a8dc21f8c884d90b6204bcd6890033aa6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8dc21f8c884d90b6204bcd6890033aa6">operator==</a> (const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr, const std::nullptr_t &amp;null)</td></tr>
<tr class="memdesc:a8dc21f8c884d90b6204bcd6890033aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with nullptr.  <br /></td></tr>
<tr class="separator:a8dc21f8c884d90b6204bcd6890033aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abd88507c603855fa51d10a83c73dbb" id="r_a6abd88507c603855fa51d10a83c73dbb"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DER, typename DEL&gt; </td></tr>
<tr class="memitem:a6abd88507c603855fa51d10a83c73dbb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6abd88507c603855fa51d10a83c73dbb">operator!=</a> (const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr, const std::nullptr_t &amp;null)</td></tr>
<tr class="memdesc:a6abd88507c603855fa51d10a83c73dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with nullptr.  <br /></td></tr>
<tr class="separator:a6abd88507c603855fa51d10a83c73dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58f360a00f6b41e2f064a4b6c0c6421" id="r_ae58f360a00f6b41e2f064a4b6c0c6421"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DER, typename DEL&gt; </td></tr>
<tr class="memitem:ae58f360a00f6b41e2f064a4b6c0c6421"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae58f360a00f6b41e2f064a4b6c0c6421">operator==</a> (const std::nullptr_t &amp;null, const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ae58f360a00f6b41e2f064a4b6c0c6421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with nullptr (reversed operands)  <br /></td></tr>
<tr class="separator:ae58f360a00f6b41e2f064a4b6c0c6421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2667642f0077e1d94fbeaafcd8cf376f" id="r_a2667642f0077e1d94fbeaafcd8cf376f"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DER, typename DEL&gt; </td></tr>
<tr class="memitem:a2667642f0077e1d94fbeaafcd8cf376f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2667642f0077e1d94fbeaafcd8cf376f">operator!=</a> (const std::nullptr_t &amp;null, const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a2667642f0077e1d94fbeaafcd8cf376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with nullptr (reversed operands)  <br /></td></tr>
<tr class="separator:a2667642f0077e1d94fbeaafcd8cf376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2fc6dcf8fe5e54dd7bafdb775e2398" id="r_aab2fc6dcf8fe5e54dd7bafdb775e2398"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_&gt; </td></tr>
<tr class="memitem:aab2fc6dcf8fe5e54dd7bafdb775e2398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab2fc6dcf8fe5e54dd7bafdb775e2398">operator&amp;</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;lbs, const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;rbs)</td></tr>
<tr class="separator:aab2fc6dcf8fe5e54dd7bafdb775e2398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4af4e6831bcb96b1bfa50c9680e1459" id="r_ab4af4e6831bcb96b1bfa50c9680e1459"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_&gt; </td></tr>
<tr class="memitem:ab4af4e6831bcb96b1bfa50c9680e1459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4af4e6831bcb96b1bfa50c9680e1459">operator|</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;lbs, const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;rbs)</td></tr>
<tr class="separator:ab4af4e6831bcb96b1bfa50c9680e1459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ec502e77d87595609396f9bae2a62" id="r_a696ec502e77d87595609396f9bae2a62"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_&gt; </td></tr>
<tr class="memitem:a696ec502e77d87595609396f9bae2a62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a696ec502e77d87595609396f9bae2a62">operator^</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;lbs, const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;rbs)</td></tr>
<tr class="separator:a696ec502e77d87595609396f9bae2a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d181a8e2dbc5b413f5484c4cf44da" id="r_a7c9d181a8e2dbc5b413f5484c4cf44da"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_&gt; </td></tr>
<tr class="memitem:a7c9d181a8e2dbc5b413f5484c4cf44da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c9d181a8e2dbc5b413f5484c4cf44da">operator~</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;bs)</td></tr>
<tr class="separator:a7c9d181a8e2dbc5b413f5484c4cf44da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4afa20ac1c112faf8c5508eee52c4a" id="r_afa4afa20ac1c112faf8c5508eee52c4a"><td class="memTemplParams" colspan="2">template&lt;typename EXTENDED&gt; </td></tr>
<tr class="memitem:afa4afa20ac1c112faf8c5508eee52c4a"><td class="memTemplItemLeft" align="right" valign="top">std::strong_ordering&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa4afa20ac1c112faf8c5508eee52c4a">operator&lt;=&gt;</a> (const EXTENDED &amp;lc, const EXTENDED &amp;rc)</td></tr>
<tr class="separator:afa4afa20ac1c112faf8c5508eee52c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db8c31a0d9119ae22cc0ee854023eb4" id="r_a1db8c31a0d9119ae22cc0ee854023eb4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1db8c31a0d9119ae22cc0ee854023eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1db8c31a0d9119ae22cc0ee854023eb4">operator&amp;&amp;</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f1, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f2)</td></tr>
<tr class="memdesc:a1db8c31a0d9119ae22cc0ee854023eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create AND <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters.  <br /></td></tr>
<tr class="separator:a1db8c31a0d9119ae22cc0ee854023eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9161566f8b79c18b9f7d44716e71ae" id="r_a1f9161566f8b79c18b9f7d44716e71ae"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1f9161566f8b79c18b9f7d44716e71ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f9161566f8b79c18b9f7d44716e71ae">operator&amp;&amp;</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f, const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:a1f9161566f8b79c18b9f7d44716e71ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>.  <br /></td></tr>
<tr class="separator:a1f9161566f8b79c18b9f7d44716e71ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c593192f7fe4c1d14e221fe9407369" id="r_a32c593192f7fe4c1d14e221fe9407369"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a32c593192f7fe4c1d14e221fe9407369"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a32c593192f7fe4c1d14e221fe9407369">operator&amp;&amp;</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:a32c593192f7fe4c1d14e221fe9407369"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter.  <br /></td></tr>
<tr class="separator:a32c593192f7fe4c1d14e221fe9407369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5022994e6fe02721e521a9a0edf56901" id="r_a5022994e6fe02721e521a9a0edf56901"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5022994e6fe02721e521a9a0edf56901"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5022994e6fe02721e521a9a0edf56901">operator||</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f1, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f2)</td></tr>
<tr class="memdesc:a5022994e6fe02721e521a9a0edf56901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OR <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters.  <br /></td></tr>
<tr class="separator:a5022994e6fe02721e521a9a0edf56901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211e12b568c0705c118b16616ea931ef" id="r_a211e12b568c0705c118b16616ea931ef"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a211e12b568c0705c118b16616ea931ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a211e12b568c0705c118b16616ea931ef">operator||</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f, const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:a211e12b568c0705c118b16616ea931ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>.  <br /></td></tr>
<tr class="separator:a211e12b568c0705c118b16616ea931ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99c956ab1ee40f5b50ec2422e5c7d9" id="r_a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b99c956ab1ee40f5b50ec2422e5c7d9">operator||</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter.  <br /></td></tr>
<tr class="separator:a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb35d1af29a0c0be3a17081b9ca9dd0" id="r_a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1fb35d1af29a0c0be3a17081b9ca9dd0">operator!</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from filter.  <br /></td></tr>
<tr class="separator:a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74fe2f9ca0a3e0a5dc33272f50e56e8" id="r_ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad74fe2f9ca0a3e0a5dc33272f50e56e8">operator!</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream.  <br /></td></tr>
<tr class="separator:ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ae231e8e4a92af1e9f3940f249c70" id="r_acd6ae231e8e4a92af1e9f3940f249c70"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:acd6ae231e8e4a92af1e9f3940f249c70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd6ae231e8e4a92af1e9f3940f249c70">group</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:acd6ae231e8e4a92af1e9f3940f249c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream.  <br /></td></tr>
<tr class="separator:acd6ae231e8e4a92af1e9f3940f249c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc95f4b01319d7d40643c55df213e3d" id="r_abcc95f4b01319d7d40643c55df213e3d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:abcc95f4b01319d7d40643c55df213e3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abcc95f4b01319d7d40643c55df213e3d">group</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:abcc95f4b01319d7d40643c55df213e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from single filter.  <br /></td></tr>
<tr class="separator:abcc95f4b01319d7d40643c55df213e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176d8ed479959a50d637c2ee6900a159" id="r_a176d8ed479959a50d637c2ee6900a159"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a176d8ed479959a50d637c2ee6900a159"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a176d8ed479959a50d637c2ee6900a159">operator+</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;it, <a class="el" href="#a583969b2c4869f07ee4fedb102e587cd">integer</a> steps) -&gt; <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *</td></tr>
<tr class="memdesc:a176d8ed479959a50d637c2ee6900a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a number of steps to the iterator's current position and returns a new iterator.  <br /></td></tr>
<tr class="separator:a176d8ed479959a50d637c2ee6900a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e78d5e4c7f280f178b3812298ef44b3" id="r_a2e78d5e4c7f280f178b3812298ef44b3"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a2e78d5e4c7f280f178b3812298ef44b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e78d5e4c7f280f178b3812298ef44b3">operator-</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;it, <a class="el" href="#a583969b2c4869f07ee4fedb102e587cd">integer</a> steps) -&gt; <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *</td></tr>
<tr class="memdesc:a2e78d5e4c7f280f178b3812298ef44b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a number of steps from the iterator's current position and returns a new iterator.  <br /></td></tr>
<tr class="separator:a2e78d5e4c7f280f178b3812298ef44b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303822f1cf65f29a40abc3883f0fb138" id="r_a303822f1cf65f29a40abc3883f0fb138"><td class="memTemplParams" colspan="2">template&lt;typename TYPE&gt; </td></tr>
<tr class="memitem:a303822f1cf65f29a40abc3883f0fb138"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a303822f1cf65f29a40abc3883f0fb138">abs</a> (TYPE a)</td></tr>
<tr class="memdesc:a303822f1cf65f29a40abc3883f0fb138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a given number.  <br /></td></tr>
<tr class="separator:a303822f1cf65f29a40abc3883f0fb138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f42f26b6aa61acc458a6bfd9c49581f" id="r_a0f42f26b6aa61acc458a6bfd9c49581f"><td class="memTemplParams" colspan="2">template&lt;typename TYPE&gt; </td></tr>
<tr class="memitem:a0f42f26b6aa61acc458a6bfd9c49581f"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f42f26b6aa61acc458a6bfd9c49581f">max</a> (TYPE a, TYPE b)</td></tr>
<tr class="memdesc:a0f42f26b6aa61acc458a6bfd9c49581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two given values.  <br /></td></tr>
<tr class="separator:a0f42f26b6aa61acc458a6bfd9c49581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d69e120da2a56a2e72fc9834edfb0ec" id="r_a0d69e120da2a56a2e72fc9834edfb0ec"><td class="memTemplParams" colspan="2">template&lt;typename TYPE&gt; </td></tr>
<tr class="memitem:a0d69e120da2a56a2e72fc9834edfb0ec"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d69e120da2a56a2e72fc9834edfb0ec">min</a> (TYPE a, TYPE b)</td></tr>
<tr class="memdesc:a0d69e120da2a56a2e72fc9834edfb0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two given values.  <br /></td></tr>
<tr class="separator:a0d69e120da2a56a2e72fc9834edfb0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890841da21078177655d939bcec43f3f" id="r_a890841da21078177655d939bcec43f3f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a890841da21078177655d939bcec43f3f">pow</a> (double base, int exp)</td></tr>
<tr class="memdesc:a890841da21078177655d939bcec43f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of raising a base to an exponent.  <br /></td></tr>
<tr class="separator:a890841da21078177655d939bcec43f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bebb9ab61ff7783b0fb2c90704246a1" id="r_a5bebb9ab61ff7783b0fb2c90704246a1"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DEL = deleter&lt;T&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a5bebb9ab61ff7783b0fb2c90704246a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5bebb9ab61ff7783b0fb2c90704246a1">makeOwnerPtr</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5bebb9ab61ff7783b0fb2c90704246a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated object.  <br /></td></tr>
<tr class="separator:a5bebb9ab61ff7783b0fb2c90704246a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c2ad6f571fb457b96abd1ab2dd660f" id="r_a84c2ad6f571fb457b96abd1ab2dd660f"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DEL = deleter&lt;T[]&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a84c2ad6f571fb457b96abd1ab2dd660f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a84c2ad6f571fb457b96abd1ab2dd660f">makeOwnerPtrArray</a> (<a class="el" href="#a2d678ae654034cea391c946ada41bd2e">u_integer</a> size, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a84c2ad6f571fb457b96abd1ab2dd660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated array.  <br /></td></tr>
<tr class="separator:a84c2ad6f571fb457b96abd1ab2dd660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf3733f8dbb6afdb7c4b4559c262da4" id="r_a6bf3733f8dbb6afdb7c4b4559c262da4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bf3733f8dbb6afdb7c4b4559c262da4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoriginal_1_1printable.html">printable</a> &amp;p)</td></tr>
<tr class="memdesc:a6bf3733f8dbb6afdb7c4b4559c262da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator for printable objects.  <br /></td></tr>
<tr class="separator:a6bf3733f8dbb6afdb7c4b4559c262da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a918750a407487641ef6924df40d8d" id="r_ab3a918750a407487641ef6924df40d8d"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DEL = deleter&lt;T&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:ab3a918750a407487641ef6924df40d8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab3a918750a407487641ef6924df40d8d">makeStrongPtr</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab3a918750a407487641ef6924df40d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared object.  <br /></td></tr>
<tr class="separator:ab3a918750a407487641ef6924df40d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70101a33a2bf1305a42a180652c98c95" id="r_a70101a33a2bf1305a42a180652c98c95"><td class="memTemplParams" colspan="2">template&lt;typename T, typename DEL = deleter&lt;T[]&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a70101a33a2bf1305a42a180652c98c95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70101a33a2bf1305a42a180652c98c95">makeStrongPtrArray</a> (<a class="el" href="#a2d678ae654034cea391c946ada41bd2e">u_integer</a> size, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a70101a33a2bf1305a42a180652c98c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared array.  <br /></td></tr>
<tr class="separator:a70101a33a2bf1305a42a180652c98c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a26f512ed3d73721da23b1f19437f6" id="r_a38a26f512ed3d73721da23b1f19437f6"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a38a26f512ed3d73721da23b1f19437f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a38a26f512ed3d73721da23b1f19437f6">operator+</a> (const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;t1, const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;t2)</td></tr>
<tr class="memdesc:a38a26f512ed3d73721da23b1f19437f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new transformation stream from two transforms.  <br /></td></tr>
<tr class="separator:a38a26f512ed3d73721da23b1f19437f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47ef543dcb851270ddb7b59ae4ae103" id="r_ae47ef543dcb851270ddb7b59ae4ae103"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae47ef543dcb851270ddb7b59ae4ae103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae47ef543dcb851270ddb7b59ae4ae103">operator+</a> (const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;t, const <a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; &amp;ots)</td></tr>
<tr class="memdesc:ae47ef543dcb851270ddb7b59ae4ae103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new stream by prefixing existing stream.  <br /></td></tr>
<tr class="separator:ae47ef543dcb851270ddb7b59ae4ae103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825c5ff9d360f357bff2e67f0191b5d8" id="r_a825c5ff9d360f357bff2e67f0191b5d8"><td class="memTemplParams" colspan="2">template&lt;typename F_TYPE, typename S_TYPE&gt; </td></tr>
<tr class="memitem:a825c5ff9d360f357bff2e67f0191b5d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; F_TYPE, S_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a825c5ff9d360f357bff2e67f0191b5d8">makeTuple</a> (const <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; F_TYPE, S_TYPE &gt; &amp;cp)</td></tr>
<tr class="separator:a825c5ff9d360f357bff2e67f0191b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d77cd1b0855c560a6ca0ec1f9754c8" id="r_a49d77cd1b0855c560a6ca0ec1f9754c8"><td class="memTemplParams" colspan="2">template&lt;typename... L_TYPES, typename... R_TYPES&gt; </td></tr>
<tr class="memitem:a49d77cd1b0855c560a6ca0ec1f9754c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; L_TYPES..., R_TYPES... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a49d77cd1b0855c560a6ca0ec1f9754c8">operator+</a> (const <a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; L_TYPES... &gt; &amp;lt, const <a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; R_TYPES... &gt; &amp;rt)</td></tr>
<tr class="separator:a49d77cd1b0855c560a6ca0ec1f9754c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6a8beb83b9110ae7cf11f70bd9d6963b" id="r_a6a8beb83b9110ae7cf11f70bd9d6963b"><td class="memTemplParams" colspan="2"><a id="a6a8beb83b9110ae7cf11f70bd9d6963b" name="a6a8beb83b9110ae7cf11f70bd9d6963b"></a>
template&lt;typename TYPE&gt; </td></tr>
<tr class="memitem:a6a8beb83b9110ae7cf11f70bd9d6963b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>filterStream&lt; TYPE &gt;::nullFilter</b> {}</td></tr>
<tr class="separator:a6a8beb83b9110ae7cf11f70bd9d6963b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f68a800f874a16bc6a433ddcf06ed5" id="r_ad9f68a800f874a16bc6a433ddcf06ed5"><td class="memItemLeft" align="right" valign="top">constexpr long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f68a800f874a16bc6a433ddcf06ed5">E</a> = 2.7182818284590452353602874713526624977572470937000L</td></tr>
<tr class="memdesc:ad9f68a800f874a16bc6a433ddcf06ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mathematical constant E (Euler's number).  <br /></td></tr>
<tr class="separator:ad9f68a800f874a16bc6a433ddcf06ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0f6145cd40bdb0d2a15907ab0a010d" id="r_a4c0f6145cd40bdb0d2a15907ab0a010d"><td class="memItemLeft" align="right" valign="top">constexpr long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c0f6145cd40bdb0d2a15907ab0a010d">PI</a> = 3.1415926535897932384626433832795028841971693993751L</td></tr>
<tr class="memdesc:a4c0f6145cd40bdb0d2a15907ab0a010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mathematical constant PI (π).  <br /></td></tr>
<tr class="separator:a4c0f6145cd40bdb0d2a15907ab0a010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the project Original. </p>
<p>This namespace serves as the main container for all modules and functionality within the Original project. It includes various classes, functions, and data structures that form the backbone of the system. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a303822f1cf65f29a40abc3883f0fb138" name="a303822f1cf65f29a40abc3883f0fb138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303822f1cf65f29a40abc3883f0fb138">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::abs </td>
          <td>(</td>
          <td class="paramtype">TYPE</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute value of a given number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of the input value.</dd></dl>
<p>This function returns the absolute value of the input argument <code>a</code>, which is the distance of <code>a</code> from zero. It works for both positive and negative values.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">int</span> a = -5;</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="#a303822f1cf65f29a40abc3883f0fb138">original::abs</a>(a); <span class="comment">// result will be 5</span></div>
<div class="ttc" id="anamespaceoriginal_html_a303822f1cf65f29a40abc3883f0fb138"><div class="ttname"><a href="#a303822f1cf65f29a40abc3883f0fb138">original::abs</a></div><div class="ttdeci">TYPE abs(TYPE a)</div><div class="ttdoc">Returns the absolute value of a given number.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abcc95f4b01319d7d40643c55df213e3d" name="abcc95f4b01319d7d40643c55df213e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc95f4b01319d7d40643c55df213e3d">&#9670;&#160;</a></span>group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from single filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter to group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a></dd></dl>
<p>Enables future operator precedence modifications </p>

</div>
</div>
<a id="acd6ae231e8e4a92af1e9f3940f249c70" name="acd6ae231e8e4a92af1e9f3940f249c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6ae231e8e4a92af1e9f3940f249c70">&#9670;&#160;</a></span>group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> to group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a></dd></dl>
<p>Use instead of parentheses for explicit precedence control </p>

</div>
</div>
<a id="a5bebb9ab61ff7783b0fb2c90704246a1" name="a5bebb9ab61ff7783b0fb2c90704246a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bebb9ab61ff7783b0fb2c90704246a1">&#9670;&#160;</a></span>makeOwnerPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DEL = deleter&lt;T&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt; original::makeOwnerPtr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to create and manage </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: <a class="el" href="classoriginal_1_1deleter.html" title="Default deletion policy for single objects.">deleter&lt;T&gt;</a>) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for object construction </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr&lt;T, DEL&gt;</a> owning the newly created object </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe object creation </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> has exclusive ownership of the object</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create an ownerPtr managing a new MyClass constructed with args</span></div>
<div class="line"><span class="keyword">auto</span> ptr = <a class="code hl_function" href="#a5bebb9ab61ff7783b0fb2c90704246a1">makeOwnerPtr&lt;MyClass&gt;</a>(arg1, arg2);</div>
<div class="ttc" id="anamespaceoriginal_html_a5bebb9ab61ff7783b0fb2c90704246a1"><div class="ttname"><a href="#a5bebb9ab61ff7783b0fb2c90704246a1">original::makeOwnerPtr</a></div><div class="ttdeci">ownerPtr&lt; T, DEL &gt; makeOwnerPtr(Args &amp;&amp;... args)</div><div class="ttdoc">Creates a new ownerPtr managing a dynamically allocated object.</div><div class="ttdef"><b>Definition</b> ownerPtr.h:167</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a84c2ad6f571fb457b96abd1ab2dd660f" name="a84c2ad6f571fb457b96abd1ab2dd660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c2ad6f571fb457b96abd1ab2dd660f">&#9670;&#160;</a></span>makeOwnerPtrArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DEL = deleter&lt;T[]&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt; original::makeOwnerPtrArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2d678ae654034cea391c946ada41bd2e">u_integer</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of array elements to create </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: <a class="el" href="classoriginal_1_1deleter.html" title="Default deletion policy for single objects.">deleter&lt;T[]&gt;</a>) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for array element initialization </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of elements in the array </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to each element's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr&lt;T, DEL&gt;</a> owning the newly created array </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe array creation </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> has exclusive ownership of the array</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create an ownerPtr managing a new MyClass[10] array</span></div>
<div class="line"><span class="keyword">auto</span> arr = <a class="code hl_function" href="#a84c2ad6f571fb457b96abd1ab2dd660f">makeOwnerPtrArray&lt;MyClass&gt;</a>(10);</div>
<div class="ttc" id="anamespaceoriginal_html_a84c2ad6f571fb457b96abd1ab2dd660f"><div class="ttname"><a href="#a84c2ad6f571fb457b96abd1ab2dd660f">original::makeOwnerPtrArray</a></div><div class="ttdeci">ownerPtr&lt; T, DEL &gt; makeOwnerPtrArray(u_integer size, Args &amp;&amp;... args)</div><div class="ttdoc">Creates a new ownerPtr managing a dynamically allocated array.</div><div class="ttdef"><b>Definition</b> ownerPtr.h:172</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab3a918750a407487641ef6924df40d8d" name="ab3a918750a407487641ef6924df40d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a918750a407487641ef6924df40d8d">&#9670;&#160;</a></span>makeStrongPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DEL = deleter&lt;T&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt; original::makeStrongPtr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to create and manage </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: <a class="el" href="classoriginal_1_1deleter.html" title="Default deletion policy for single objects.">deleter&lt;T&gt;</a>) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for object construction </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr&lt;T, DEL&gt;</a> sharing ownership of the new object </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe object creation with shared ownership</dd></dl>
<p>The object will be destroyed when all strong references are released</p>
<div class="fragment"><div class="line"><span class="comment">// Create a strongPtr managing a new MyClass constructed with args</span></div>
<div class="line"><span class="keyword">auto</span> ptr = <a class="code hl_function" href="#ab3a918750a407487641ef6924df40d8d">makeStrongPtr&lt;MyClass&gt;</a>(arg1, arg2);</div>
<div class="ttc" id="anamespaceoriginal_html_ab3a918750a407487641ef6924df40d8d"><div class="ttname"><a href="#ab3a918750a407487641ef6924df40d8d">original::makeStrongPtr</a></div><div class="ttdeci">strongPtr&lt; T, DEL &gt; makeStrongPtr(Args &amp;&amp;... args)</div><div class="ttdoc">Creates a new strongPtr managing a shared object.</div><div class="ttdef"><b>Definition</b> refCntPtr.h:445</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a70101a33a2bf1305a42a180652c98c95" name="a70101a33a2bf1305a42a180652c98c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70101a33a2bf1305a42a180652c98c95">&#9670;&#160;</a></span>makeStrongPtrArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DEL = deleter&lt;T[]&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt; original::makeStrongPtrArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2d678ae654034cea391c946ada41bd2e">u_integer</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of array elements to create </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: <a class="el" href="classoriginal_1_1deleter.html" title="Default deletion policy for single objects.">deleter&lt;T[]&gt;</a>) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for array element initialization </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of elements in the array </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to each element's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr&lt;T, DEL&gt;</a> sharing ownership of the new array </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe array creation with shared ownership</dd></dl>
<p>The array will be destroyed when all strong references are released</p>
<div class="fragment"><div class="line"><span class="comment">// Create a strongPtr managing a new MyClass[10] array</span></div>
<div class="line"><span class="keyword">auto</span> arr = <a class="code hl_function" href="#a70101a33a2bf1305a42a180652c98c95">makeStrongPtrArray&lt;MyClass&gt;</a>(10);</div>
<div class="ttc" id="anamespaceoriginal_html_a70101a33a2bf1305a42a180652c98c95"><div class="ttname"><a href="#a70101a33a2bf1305a42a180652c98c95">original::makeStrongPtrArray</a></div><div class="ttdeci">strongPtr&lt; T, DEL &gt; makeStrongPtrArray(u_integer size, Args &amp;&amp;... args)</div><div class="ttdoc">Creates a new strongPtr managing a shared array.</div><div class="ttdef"><b>Definition</b> refCntPtr.h:450</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a825c5ff9d360f357bff2e67f0191b5d8" name="a825c5ff9d360f357bff2e67f0191b5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825c5ff9d360f357bff2e67f0191b5d8">&#9670;&#160;</a></span>makeTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F_TYPE, typename S_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; F_TYPE, S_TYPE &gt; original::makeTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; F_TYPE, S_TYPE &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F_TYPE</td><td>Type of the first element </td></tr>
    <tr><td class="paramname">S_TYPE</td><td>Type of the second element </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cp</td><td>The couple to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple with the couple's elements </dd></dl>

</div>
</div>
<a id="a0f42f26b6aa61acc458a6bfd9c49581f" name="a0f42f26b6aa61acc458a6bfd9c49581f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f42f26b6aa61acc458a6bfd9c49581f">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::max </td>
          <td>(</td>
          <td class="paramtype">TYPE</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the larger of two given values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the input values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first input value. </td></tr>
    <tr><td class="paramname">b</td><td>The second input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The larger of <code>a</code> and <code>b</code>.</dd></dl>
<p>This function compares the two values <code>a</code> and <code>b</code>, and returns the value that is greater.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">double</span> a = 3.5, b = 7.2;</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="#a0f42f26b6aa61acc458a6bfd9c49581f">original::max</a>(a, b); <span class="comment">// result will be 7.2</span></div>
<div class="ttc" id="anamespaceoriginal_html_a0f42f26b6aa61acc458a6bfd9c49581f"><div class="ttname"><a href="#a0f42f26b6aa61acc458a6bfd9c49581f">original::max</a></div><div class="ttdeci">TYPE max(TYPE a, TYPE b)</div><div class="ttdoc">Returns the larger of two given values.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0d69e120da2a56a2e72fc9834edfb0ec" name="a0d69e120da2a56a2e72fc9834edfb0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d69e120da2a56a2e72fc9834edfb0ec">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::min </td>
          <td>(</td>
          <td class="paramtype">TYPE</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smaller of two given values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the input values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first input value. </td></tr>
    <tr><td class="paramname">b</td><td>The second input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller of <code>a</code> and <code>b</code>.</dd></dl>
<p>This function compares the two values <code>a</code> and <code>b</code>, and returns the value that is smaller.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">double</span> a = 3.5, b = 7.2;</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="#a0d69e120da2a56a2e72fc9834edfb0ec">original::min</a>(a, b); <span class="comment">// result will be 3.5</span></div>
<div class="ttc" id="anamespaceoriginal_html_a0d69e120da2a56a2e72fc9834edfb0ec"><div class="ttname"><a href="#a0d69e120da2a56a2e72fc9834edfb0ec">original::min</a></div><div class="ttdeci">TYPE min(TYPE a, TYPE b)</div><div class="ttdoc">Returns the smaller of two given values.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1fb35d1af29a0c0be3a17081b9ca9dd0" name="a1fb35d1af29a0c0be3a17081b9ca9dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb35d1af29a0c0be3a17081b9ca9dd0">&#9670;&#160;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> with NOT operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically adds grouping parentheses </dd></dl>

</div>
</div>
<a id="ad74fe2f9ca0a3e0a5dc33272f50e56e8" name="ad74fe2f9ca0a3e0a5dc33272f50e56e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74fe2f9ca0a3e0a5dc33272f50e56e8">&#9670;&#160;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically adds grouping parentheses </dd></dl>

</div>
</div>
<a id="a6abd88507c603855fa51d10a83c73dbb" name="a6abd88507c603855fa51d10a83c73dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abd88507c603855fa51d10a83c73dbb">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DER, typename DEL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="#a1fb35d1af29a0c0be3a17081b9ca9dd0">original::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t &amp;</td>          <td class="paramname"><span class="paramname"><em>null</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison with nullptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is not empty (has a managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking operator bool() of ptr </dd></dl>

</div>
</div>
<a id="a2667642f0077e1d94fbeaafcd8cf376f" name="a2667642f0077e1d94fbeaafcd8cf376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2667642f0077e1d94fbeaafcd8cf376f">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DER, typename DEL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="#a1fb35d1af29a0c0be3a17081b9ca9dd0">original::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t &amp;</td>          <td class="paramname"><span class="paramname"><em>null</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison with nullptr (reversed operands) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is not empty (has a managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking operator bool() of ptr </dd></dl>

</div>
</div>
<a id="aab2fc6dcf8fe5e54dd7bafdb775e2398" name="aab2fc6dcf8fe5e54dd7bafdb775e2398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2fc6dcf8fe5e54dd7bafdb775e2398">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rbs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbs</td><td>The left <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
    <tr><td class="paramname">rbs</td><td>The right <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the AND operation. </dd></dl>

</div>
</div>
<a id="a1f9161566f8b79c18b9f7d44716e71ae" name="a1f9161566f8b79c18b9f7d44716e71ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9161566f8b79c18b9f7d44716e71ae">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AND operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a1db8c31a0d9119ae22cc0ee854023eb4" name="a1db8c31a0d9119ae22cc0ee854023eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db8c31a0d9119ae22cc0ee854023eb4">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create AND <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>First filter operand </td></tr>
    <tr><td class="paramname">f2</td><td>Second filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> with AND operation </dd></dl>

</div>
</div>
<a id="a32c593192f7fe4c1d14e221fe9407369" name="a32c593192f7fe4c1d14e221fe9407369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c593192f7fe4c1d14e221fe9407369">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AND operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a176d8ed479959a50d637c2ee6900a159" name="a176d8ed479959a50d637c2ee6900a159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176d8ed479959a50d637c2ee6900a159">&#9670;&#160;</a></span>operator+() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a583969b2c4869f07ee4fedb102e587cd">integer</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>&#160;) -&gt; <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt;T&gt;*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a number of steps to the iterator's current position and returns a new iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements the iterator will traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to move. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to move forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that is moved forward by the specified steps from the original iterator.</dd></dl>
<p>This operator does not modify the original iterator, but creates a new one that is advanced by <code>steps</code> positions. </p>

</div>
</div>
<a id="ae47ef543dcb851270ddb7b59ae4ae103" name="ae47ef543dcb851270ddb7b59ae4ae103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47ef543dcb851270ddb7b59ae4ae103">&#9670;&#160;</a></span>operator+() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ots</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new stream by prefixing existing stream. </p>
<p>Creates new stream from transformation and existing stream.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Transformation to prepend </td></tr>
    <tr><td class="paramname">ots</td><td>Original stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New stream applying t then ots's transformations </dd></dl>

</div>
</div>
<a id="a38a26f512ed3d73721da23b1f19437f6" name="a38a26f512ed3d73721da23b1f19437f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a26f512ed3d73721da23b1f19437f6">&#9670;&#160;</a></span>operator+() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel related">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new transformation stream from two transforms. </p>
<p>Creates new stream from two transformations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First transformation </td></tr>
    <tr><td class="paramname">t2</td><td>Second transformation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New stream applying t1 then t2 </dd></dl>

</div>
</div>
<a id="a49d77cd1b0855c560a6ca0ec1f9754c8" name="a49d77cd1b0855c560a6ca0ec1f9754c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d77cd1b0855c560a6ca0ec1f9754c8">&#9670;&#160;</a></span>operator+() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... L_TYPES, typename... R_TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; L_TYPES..., R_TYPES... &gt; original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; L_TYPES... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; R_TYPES... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L_TYPES</td><td>Types of the left tuple's elements </td></tr>
    <tr><td class="paramname">R_TYPES</td><td>Types of the right tuple's elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lt</td><td>The left tuple </td></tr>
    <tr><td class="paramname">rt</td><td>The right tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple combining elements from both tuples </dd></dl>

</div>
</div>
<a id="a2e78d5e4c7f280f178b3812298ef44b3" name="a2e78d5e4c7f280f178b3812298ef44b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e78d5e4c7f280f178b3812298ef44b3">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a583969b2c4869f07ee4fedb102e587cd">integer</a></td>          <td class="paramname"><span class="paramname"><em>steps</em></span>&#160;) -&gt; <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt;T&gt;*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a number of steps from the iterator's current position and returns a new iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements the iterator will traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to move. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to move backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that is moved backward by the specified steps from the original iterator.</dd></dl>
<p>This operator does not modify the original iterator, but creates a new one that is moved backward by <code>steps</code> positions. </p>

</div>
</div>
<a id="a6bf3733f8dbb6afdb7c4b4559c262da4" name="a6bf3733f8dbb6afdb7c4b4559c262da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf3733f8dbb6afdb7c4b4559c262da4">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; original::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1printable.html">printable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream insertion operator for printable objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">p</td><td>Printable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Modified output stream</dd></dl>
<div class="fragment"><div class="line">Myclass : <span class="keyword">public</span> <a class="code hl_class" href="classoriginal_1_1printable.html">printable</a>{};</div>
<div class="line"> </div>
<div class="line">MyClass obj;</div>
<div class="line">std::cout &lt;&lt; obj; <span class="comment">// Outputs &quot;printable(@0x7ffd) \n&quot;</span></div>
<div class="ttc" id="aclassoriginal_1_1printable_html"><div class="ttname"><a href="classoriginal_1_1printable.html">original::printable</a></div><div class="ttdoc">Base class providing polymorphic string conversion capabilities.</div><div class="ttdef"><b>Definition</b> printable.h:25</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afa4afa20ac1c112faf8c5508eee52c4a" name="afa4afa20ac1c112faf8c5508eee52c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4afa20ac1c112faf8c5508eee52c4a">&#9670;&#160;</a></span>operator&lt;=&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EXTENDED&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::strong_ordering original::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const EXTENDED &amp;</td>          <td class="paramname"><span class="paramname"><em>lc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EXTENDED &amp;</td>          <td class="paramname"><span class="paramname"><em>rc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator is implemented by invoking the compareTo() method of the comparable object. The result type is std::strong_ordering, indicating strong ordering semantics. Defined as a friend function to enable symmetric argument handling.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EXTENDED</td><td>The actual derived type using CRTP pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lc</td><td>Left-hand side comparable object </td></tr>
    <tr><td class="paramname">rc</td><td>Right-hand side comparable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::strong_ordering<ul>
<li>std::strong_ordering::less if lhs &lt; rhs</li>
<li>std::strong_ordering::equal if lhs == rhs</li>
<li>std::strong_ordering::greater if lhs &gt; rhs </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a8dc21f8c884d90b6204bcd6890033aa6" name="a8dc21f8c884d90b6204bcd6890033aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc21f8c884d90b6204bcd6890033aa6">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DER, typename DEL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t &amp;</td>          <td class="paramname"><span class="paramname"><em>null</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison with nullptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is empty (no managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking !operator bool() of ptr </dd></dl>

</div>
</div>
<a id="ae58f360a00f6b41e2f064a4b6c0c6421" name="ae58f360a00f6b41e2f064a4b6c0c6421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58f360a00f6b41e2f064a4b6c0c6421">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename DER, typename DEL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t &amp;</td>          <td class="paramname"><span class="paramname"><em>null</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison with nullptr (reversed operands) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is empty (no managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking !operator bool() of ptr </dd></dl>

</div>
</div>
<a id="a696ec502e77d87595609396f9bae2a62" name="a696ec502e77d87595609396f9bae2a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ec502e77d87595609396f9bae2a62">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rbs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbs</td><td>The left <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
    <tr><td class="paramname">rbs</td><td>The right <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the XOR operation. </dd></dl>

</div>
</div>
<a id="ab4af4e6831bcb96b1bfa50c9680e1459" name="ab4af4e6831bcb96b1bfa50c9680e1459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af4e6831bcb96b1bfa50c9680e1459">&#9670;&#160;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rbs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbs</td><td>The left <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
    <tr><td class="paramname">rbs</td><td>The right <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the OR operation. </dd></dl>

</div>
</div>
<a id="a211e12b568c0705c118b16616ea931ef" name="a211e12b568c0705c118b16616ea931ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211e12b568c0705c118b16616ea931ef">&#9670;&#160;</a></span>operator||() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OR operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a5022994e6fe02721e521a9a0edf56901" name="a5022994e6fe02721e521a9a0edf56901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5022994e6fe02721e521a9a0edf56901">&#9670;&#160;</a></span>operator||() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OR <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>First filter operand </td></tr>
    <tr><td class="paramname">f2</td><td>Second filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> with OR operation </dd></dl>

</div>
</div>
<a id="a9b99c956ab1ee40f5b50ec2422e5c7d9" name="a9b99c956ab1ee40f5b50ec2422e5c7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b99c956ab1ee40f5b50ec2422e5c7d9">&#9670;&#160;</a></span>operator||() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ofs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OR operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a7c9d181a8e2dbc5b413f5484c4cf44da" name="a7c9d181a8e2dbc5b413f5484c4cf44da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9d181a8e2dbc5b413f5484c4cf44da">&#9670;&#160;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>The <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a> to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the NOT operation. </dd></dl>

</div>
</div>
<a id="a890841da21078177655d939bcec43f3f" name="a890841da21078177655d939bcec43f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890841da21078177655d939bcec43f3f">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto original::pow </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>exp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of raising a base to an exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base value. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of <code>base</code> raised to the power of <code>exp</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classoriginal_1_1valueError.html" title="Exception for invalid parameter values.">valueError</a></td><td>If <code>base</code> is 0 and <code>exp</code> is less than or equal to 0.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs exponentiation by iterating <code>exp</code> times and multiplying the base. If <code>exp</code> is negative, it computes the reciprocal of the result. An exception is thrown if <code>base</code> is 0 and <code>exp</code> is non-positive.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">double</span> base = 2.0;</div>
<div class="line"><span class="keywordtype">int</span> exp = 3;</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="#a890841da21078177655d939bcec43f3f">original::pow</a>(base, exp); <span class="comment">// result will be 8.0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For negative exponent:</span></div>
<div class="line">exp = -2;</div>
<div class="line">result = <a class="code hl_function" href="#a890841da21078177655d939bcec43f3f">original::pow</a>(base, exp); <span class="comment">// result will be 0.25</span></div>
<div class="ttc" id="anamespaceoriginal_html_a890841da21078177655d939bcec43f3f"><div class="ttname"><a href="#a890841da21078177655d939bcec43f3f">original::pow</a></div><div class="ttdeci">double pow(double base, int exp)</div><div class="ttdoc">Returns the result of raising a base to an exponent.</div><div class="ttdef"><b>Definition</b> maths.h:129</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad9f68a800f874a16bc6a433ddcf06ed5" name="ad9f68a800f874a16bc6a433ddcf06ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f68a800f874a16bc6a433ddcf06ed5">&#9670;&#160;</a></span>E</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double original::E = 2.7182818284590452353602874713526624977572470937000L</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mathematical constant E (Euler's number). </p>
<p>This is the base of the natural logarithm, approximately equal to 2.71828. It is used in various mathematical, scientific, and engineering applications, particularly in exponential growth and decay models, as well as in complex analysis. </p>

</div>
</div>
<a id="a4c0f6145cd40bdb0d2a15907ab0a010d" name="a4c0f6145cd40bdb0d2a15907ab0a010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0f6145cd40bdb0d2a15907ab0a010d">&#9670;&#160;</a></span>PI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long double original::PI = 3.1415926535897932384626433832795028841971693993751L</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mathematical constant PI (π). </p>
<p>This is the ratio of a circle's circumference to its diameter, approximately equal to 3.14159. It is used in geometry, trigonometry, and many other mathematical fields, especially when dealing with circular or spherical shapes. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
