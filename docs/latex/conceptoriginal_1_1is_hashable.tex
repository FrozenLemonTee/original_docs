\doxysection{original\+::is\+Hashable Concept Reference}
\hypertarget{conceptoriginal_1_1is_hashable}{}\label{conceptoriginal_1_1is_hashable}\index{original::isHashable@{original::isHashable}}


Concept checking for types that can be hashed.  




{\ttfamily \#include $<$hash.\+h$>$}

\doxysubsection{Concept definition}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ DERIVED>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }\mbox{\hyperlink{conceptoriginal_1_1is_hashable}{original::isHashable}}\ =\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{requires}(\textcolor{keyword}{const}\ DERIVED\&\ t,\ \textcolor{keyword}{const}\ DERIVED\&\ other)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ t.toHash()\ \}\ -\/>\ std::same\_as<u\_integer>;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{\ t.equals(other)\ \}\ -\/>\ std::same\_as<bool>;}
\DoxyCodeLine{\ \ \ \ \}}

\end{DoxyCode}


\doxysubsection{Detailed Description}
Concept checking for types that can be hashed. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DERIVED} & The type to be checked\\
\hline
\end{DoxyTemplParams}
Requires the type to implement\+:
\begin{DoxyItemize}
\item to\+Hash() method returning u\+\_\+integer
\item equals() method taking const DERIVED\& and returning bool
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }MyHashable\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{group___type_definitions_ga2d678ae654034cea391c946ada41bd2e}{u\_integer}}\ toHash()\ const\ noexcept\ \{\ \textcolor{keywordflow}{return}\ 42;\ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ equals(\textcolor{keyword}{const}\ MyHashable\&)\ \textcolor{keyword}{const}\ \textcolor{keyword}{noexcept}\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(isHashable<MyHashable>);\ \ \textcolor{comment}{//\ Passes}}

\end{DoxyCode}
 