<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ORIGINAL: original Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ORIGINAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#concepts">Concepts</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">original Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Main namespace for the project Original.  
<a href="namespaceoriginal.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1absTransform.html">absTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that converts an element to its absolute value.  <a href="classoriginal_1_1absTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1addOptTransform.html">addOptTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that adds a given value to an element.  <a href="classoriginal_1_1addOptTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1algorithms.html">algorithms</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class containing generic container algorithms.  <a href="classoriginal_1_1algorithms.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocateError.html">allocateError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for memory allocation failures.  <a href="classoriginal_1_1allocateError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocator.html">allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default memory allocator using allocators utilities.  <a href="classoriginal_1_1allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocatorBase.html">allocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for other memory allocator implementations.  <a href="classoriginal_1_1allocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1allocators.html">allocators</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class providing static memory allocation/de-allocation functions.  <a href="classoriginal_1_1allocators.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1alternative.html">alternative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-safe container that may or may not contain a value.  <a href="classoriginal_1_1alternative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1alternative_3_01void_01_4.html">alternative&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-size array container with random access.  <a href="classoriginal_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1assignOptTransform.html">assignOptTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that assigns a specified value to an element.  <a href="classoriginal_1_1assignOptTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1async.html">async</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous programming utilities with future/promise pattern.  <a href="classoriginal_1_1async.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base smart pointer with reference counting.  <a href="classoriginal_1_1autoPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseArray.html">baseArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for fixed-size serial containers.  <a href="classoriginal_1_1baseArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseCloneable.html">baseCloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class that defines a cloneable interface.  <a href="classoriginal_1_1baseCloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseIterator.html">baseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for basic iterators.  <a href="classoriginal_1_1baseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1baseList.html">baseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for variable-size serial containers.  <a href="classoriginal_1_1baseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a set of bits, offering functionality to manipulate and query individual bits.  <a href="classoriginal_1_1bitSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1blocksList.html">blocksList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A block-based list implementation.  <a href="classoriginal_1_1blocksList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1callBackChecker.html">callBackChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static utility for validating callback signatures.  <a href="classoriginal_1_1callBackChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1callbackReturnTypeError.html">callbackReturnTypeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for callback return type mismatch.  <a href="classoriginal_1_1callbackReturnTypeError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1callbackSignatureError.html">callbackSignatureError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for callback argument mismatch.  <a href="classoriginal_1_1callbackSignatureError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1chain.html">chain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-cyclic doubly linked list container.  <a href="classoriginal_1_1chain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1cloneable.html">cloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete cloneable class with custom cloning behavior.  <a href="classoriginal_1_1cloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparable.html">comparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for comparable objects.  <a href="classoriginal_1_1comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1comparator.html">comparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for comparison.  <a href="classoriginal_1_1comparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1conditionBase.html">conditionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for condition variable implementations.  <a href="classoriginal_1_1conditionBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1container.html">container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for containers.  <a href="classoriginal_1_1container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1containerAdapter.html">containerAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter class that provides unified interface for various container types.  <a href="classoriginal_1_1containerAdapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1copyTransform.html">copyTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that copies an element into a container.  <a href="classoriginal_1_1copyTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1coroutine.html">coroutine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1couple.html">couple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for two heterogeneous elements.  <a href="classoriginal_1_1couple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1decreaseComparator.html">decreaseComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for decreasing comparison (greater than).  <a href="classoriginal_1_1decreaseComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1decreaseNotStrictComparator.html">decreaseNotStrictComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for non-strict decreasing comparison (greater than or equal to).  <a href="classoriginal_1_1decreaseNotStrictComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleter.html">deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default deletion policy for single objects.  <a href="classoriginal_1_1deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleter_3_01TYPE_0f_0e_4.html">deleter&lt; TYPE[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleterBase.html">deleterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for deleters defining the deletion policy interface.  <a href="classoriginal_1_1deleterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deleterBase_3_01TYPE_0f_0e_00_01DERIVED_01_4.html">deleterBase&lt; TYPE[], DERIVED &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1deque.html">deque</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-ended queue container adapter.  <a href="classoriginal_1_1deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1doubleDirectionIterator.html">doubleDirectionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for double-direction iterators.  <a href="classoriginal_1_1doubleDirectionIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1equalComparator.html">equalComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for equality comparison.  <a href="classoriginal_1_1equalComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1equalFilter.html">equalFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is equal to a target value.  <a href="classoriginal_1_1equalFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1error.html">error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exceptions in the Original project.  <a href="classoriginal_1_1error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1filter.html">filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for filter operations.  <a href="classoriginal_1_1filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite filter builder with logical operator chaining.  <a href="classoriginal_1_1filterStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1forwardChain.html">forwardChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A singly linked list implementation.  <a href="classoriginal_1_1forwardChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoriginal_1_1functionTraits.html">functionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template for general callable types.  <a href="structoriginal_1_1functionTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoriginal_1_1functionTraits_3_01R_07_5_08_07Args_8_8_8_08_4.html">functionTraits&lt; R(*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for function pointers.  <a href="structoriginal_1_1functionTraits_3_01R_07_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoriginal_1_1functionTraits_3_01R_07Args_8_8_8_08_4.html">functionTraits&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for function types.  <a href="structoriginal_1_1functionTraits_3_01R_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoriginal_1_1functionTraits_3_01R_07C_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">functionTraits&lt; R(C::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for const member function pointers.  <a href="structoriginal_1_1functionTraits_3_01R_07C_1_1_5_08_07Args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoriginal_1_1functionTraits_3_01R_07C_1_1_5_08_07Args_8_8_8_08_4.html">functionTraits&lt; R(C::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for non-const member function pointers.  <a href="structoriginal_1_1functionTraits_3_01R_07C_1_1_5_08_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1genPipe.html">genPipe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe adapter for generator operations to enable fluent chaining.  <a href="classoriginal_1_1genPipe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1greaterFilter.html">greaterFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is greater than a target value.  <a href="classoriginal_1_1greaterFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1hash.html">hash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic hash function object supporting multiple types.  <a href="classoriginal_1_1hash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1hashable.html">hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration of hashable interface template.  <a href="classoriginal_1_1hashable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1hashMap.html">hashMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table based implementation of the map interface.  <a href="classoriginal_1_1hashMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1hashSet.html">hashSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table based implementation of the set interface.  <a href="classoriginal_1_1hashSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1hashTable.html">hashTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table implementation with separate chaining.  <a href="classoriginal_1_1hashTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1increaseComparator.html">increaseComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for increasing comparison (less than).  <a href="classoriginal_1_1increaseComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1increaseNotStrictComparator.html">increaseNotStrictComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for non-strict increasing comparison (less than or equal to).  <a href="classoriginal_1_1increaseNotStrictComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1indexSequence.html">indexSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time sequence of unsigned integers.  <a href="classoriginal_1_1indexSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1iterable.html">iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for iterable containers that support multiple iteration patterns.  <a href="classoriginal_1_1iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1iterationStream.html">iterationStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream class that allows iteration, comparison, and printing.  <a href="classoriginal_1_1iterationStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base iterator interface that supports common operations for iteration.  <a href="classoriginal_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1JMap.html">JMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip List based implementation of the map interface.  <a href="classoriginal_1_1JMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1JSet.html">JSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip List based implementation of the set interface.  <a href="classoriginal_1_1JSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1lessFilter.html">lessFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is less than a target value.  <a href="classoriginal_1_1lessFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1lockGuard.html">lockGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for lock guard implementations.  <a href="classoriginal_1_1lockGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1makeIndexSequence.html">makeIndexSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for generating index sequences.  <a href="classoriginal_1_1makeIndexSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1map.html">map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for key-value mapping containers.  <a href="classoriginal_1_1map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1multiLock.html">multiLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for multiple mutex locking.  <a href="classoriginal_1_1multiLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1multiOptTransform.html">multiOptTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation that multiplies an element by a given value.  <a href="classoriginal_1_1multiOptTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1mutexBase.html">mutexBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for mutex implementations.  <a href="classoriginal_1_1mutexBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1noElementError.html">noElementError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for missing element requests.  <a href="classoriginal_1_1noElementError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1none.html">none</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder type representing the absence of a value.  <a href="classoriginal_1_1none.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notEqualComparator.html">notEqualComparator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparator for inequality comparison.  <a href="classoriginal_1_1notEqualComparator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notEqualFilter.html">notEqualFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is not equal to a target value.  <a href="classoriginal_1_1notEqualFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notGreaterFilter.html">notGreaterFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is less than or equal to a target value.  <a href="classoriginal_1_1notGreaterFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1notLessFilter.html">notLessFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element is greater than or equal to a target value.  <a href="classoriginal_1_1notLessFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1nullPointerError.html">nullPointerError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for null pointer dereference attempts.  <a href="classoriginal_1_1nullPointerError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1objPoolAllocator.html">objPoolAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object pool allocator for efficient fixed-size memory management.  <a href="classoriginal_1_1objPoolAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1outOfBoundError.html">outOfBoundError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for container index out-of-range errors.  <a href="classoriginal_1_1outOfBoundError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique ownership smart pointer with move semantics.  <a href="classoriginal_1_1ownerPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1pCondition.html">pCondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POSIX condition variable implementation.  <a href="classoriginal_1_1pCondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1pMutex.html">pMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POSIX thread mutex implementation.  <a href="classoriginal_1_1pMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1printable.html">printable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing polymorphic string conversion capabilities.  <a href="classoriginal_1_1printable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1prique.html">prique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap-based priority queue container.  <a href="classoriginal_1_1prique.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1pThread.html">pThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POSIX thread implementation.  <a href="classoriginal_1_1pThread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1queue.html">queue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">First-In-First-Out (FIFO) container adapter.  <a href="classoriginal_1_1queue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1randomAccessIterator.html">randomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for random-access iterators.  <a href="classoriginal_1_1randomAccessIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1rangeFilter.html">rangeFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A filter that checks if an element lies within a specified range.  <a href="classoriginal_1_1rangeFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1RBTree.html">RBTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Red-Black Tree container implementation.  <a href="classoriginal_1_1RBTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1refCntPtr.html">refCntPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference-counted pointers.  <a href="classoriginal_1_1refCntPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1refCount.html">refCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference counting metadata container.  <a href="classoriginal_1_1refCount.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1refCountBase.html">refCountBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for reference counting metadata.  <a href="classoriginal_1_1refCountBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1semaphore.html">semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counting semaphore with maximum count constraint.  <a href="classoriginal_1_1semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1semaphore_3_010_01_4.html">semaphore&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1semaphoreGuard.html">semaphoreGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for automatic semaphore management.  <a href="classoriginal_1_1semaphoreGuard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1serial.html">serial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for sequential containers with index-based access.  <a href="classoriginal_1_1serial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1set.html">set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for unique element containers.  <a href="classoriginal_1_1set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1singleDirectionIterator.html">singleDirectionIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for single-direction iterators.  <a href="classoriginal_1_1singleDirectionIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1singleton.html">singleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe singleton pattern implementation with ownership management.  <a href="classoriginal_1_1singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1skipList.html">skipList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skip List container implementation.  <a href="classoriginal_1_1skipList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1stack.html">stack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last-In-First-Out (LIFO) container adapter.  <a href="classoriginal_1_1stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError.html">staticError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time error triggering utility.  <a href="classoriginal_1_1staticError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1allocateError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::allocateError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1callbackReturnTypeError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::callbackReturnTypeError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1callbackSignatureError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::callbackSignatureError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1error_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::error, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1noElementError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::noElementError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1nullPointerError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::nullPointerError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1outOfBoundError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::outOfBoundError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1sysError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::sysError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1unSupportedMethodError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::unSupportedMethodError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1staticError_3_01original_1_1valueError_00_01TRIGGERING__CONDITION_01_4.html">staticError&lt; original::valueError, TRIGGERING_CONDITION &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1stepIterator.html">stepIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for step iterators.  <a href="classoriginal_1_1stepIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared ownership smart pointer with strong references.  <a href="classoriginal_1_1strongPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1syncPoint.html">syncPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronization point for multiple threads.  <a href="classoriginal_1_1syncPoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1sysError.html">sysError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for generic system failure.  <a href="classoriginal_1_1sysError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1taskDelegator.html">taskDelegator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread pool for managing and executing prioritized tasks.  <a href="classoriginal_1_1taskDelegator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-level thread wrapper.  <a href="classoriginal_1_1thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1threadBase.html">threadBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for thread implementations.  <a href="classoriginal_1_1threadBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1time.html">time</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace-like class containing time-related utilities.  <a href="classoriginal_1_1time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1transform.html">transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for transformation operations.  <a href="classoriginal_1_1transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered sequence of transformation operations.  <a href="classoriginal_1_1transformStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1treeMap.html">treeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Red-Black Tree based implementation of the map interface.  <a href="classoriginal_1_1treeMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1treeSet.html">treeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Red-Black Tree based implementation of the set interface.  <a href="classoriginal_1_1treeSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1tuple.html">tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for multiple heterogeneous elements.  <a href="classoriginal_1_1tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1uniqueLock.html">uniqueLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII wrapper for single mutex locking.  <a href="classoriginal_1_1uniqueLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1unSupportedMethodError.html">unSupportedMethodError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for unimplemented method calls.  <a href="classoriginal_1_1unSupportedMethodError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1valueError.html">valueError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for invalid parameter values.  <a href="classoriginal_1_1valueError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array container with amortized constant time operations.  <a href="classoriginal_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1weakPtr.html">weakPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-owning reference to shared resource.  <a href="classoriginal_1_1weakPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoriginal_1_1wrapper.html">wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for linked value containers with formatted output.  <a href="classoriginal_1_1wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1NotNull.html">NotNull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures the parameter pack is not empty. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1EnumType.html">EnumType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to be an enumeration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1EnumClassType.html">EnumClassType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to be a scoped enumeration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1EqualityComparable.html">EqualityComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support equality comparison operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1WeaklyOrdered.html">WeaklyOrdered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support relational comparison operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1PartiallyComparable.html">PartiallyComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support either equality or relational comparisons. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1TotallyComparable.html">TotallyComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support all comparison operators. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1ThreeWayComparable.html">ThreeWayComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support three-way comparison (spaceship operator). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1StronglyOrdered.html">StronglyOrdered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support strong ordering via three-way comparison. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Comparable.html">Comparable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1CmpTraits.html">CmpTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Printable.html">Printable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support output stream insertion. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1InputStreamable.html">InputStreamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support input stream extraction. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Streamable.html">Streamable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support both input and output stream operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Hashable.html">Hashable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept checking for types that can be hashed. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Equatable.html">Equatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requires type to support equality comparison for hashing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1HashTraits.html">HashTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Callable.html">Callable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic concept for any callable type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1CallbackOf.html">CallbackOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates callback signature compatibility. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Predicate.html">Predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint for boolean predicate callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Compare.html">Compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines Comparable and CallbackOf for comparison callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Condition.html">Condition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint for predicate callbacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint for mutating operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Transformer.html">Transformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constraint for transformation operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1SuperOf.html">SuperOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks inheritance or type equality. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1ExtendsOf.html">ExtendsOf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks derivation or type identity using std::derived_from. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1ConvertibleTo.html">ConvertibleTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if type is convertible to another type. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1SameAs.html">SameAs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two types are exactly the same. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1Container.html">Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic container concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="conceptoriginal_1_1SequenceContainer.html">SequenceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence container concept. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga31f8a217f9ea5f5699e088f7f12ce9fb" id="r_ga31f8a217f9ea5f5699e088f7f12ce9fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#ga31f8a217f9ea5f5699e088f7f12ce9fb">byte</a> = std::uint8_t</td></tr>
<tr class="memdesc:ga31f8a217f9ea5f5699e088f7f12ce9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned 8-bit integer type (byte)  <br /></td></tr>
<tr class="separator:ga31f8a217f9ea5f5699e088f7f12ce9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2708a046626d5946db91463d4879db6c" id="r_ga2708a046626d5946db91463d4879db6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#ga2708a046626d5946db91463d4879db6c">s_byte</a> = std::int8_t</td></tr>
<tr class="memdesc:ga2708a046626d5946db91463d4879db6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signed 8-bit integer type.  <br /></td></tr>
<tr class="separator:ga2708a046626d5946db91463d4879db6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7016f36aa0d4425ae6207f689a421784" id="r_ga7016f36aa0d4425ae6207f689a421784"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> = std::int64_t</td></tr>
<tr class="memdesc:ga7016f36aa0d4425ae6207f689a421784"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integer type for arithmetic operations  <br /></td></tr>
<tr class="separator:ga7016f36aa0d4425ae6207f689a421784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00034df66aefa8043fc1bf5f02ec9392" id="r_ga00034df66aefa8043fc1bf5f02ec9392"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> = std::uint32_t</td></tr>
<tr class="memdesc:ga00034df66aefa8043fc1bf5f02ec9392"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integer type for sizes and indexes  <br /></td></tr>
<tr class="separator:ga00034df66aefa8043fc1bf5f02ec9392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e335b203e5f8d441f4a334b2b3be8e" id="r_ga56e335b203e5f8d441f4a334b2b3be8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#ga56e335b203e5f8d441f4a334b2b3be8e">ul_integer</a> = std::uint64_t</td></tr>
<tr class="memdesc:ga56e335b203e5f8d441f4a334b2b3be8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integer type  <br /></td></tr>
<tr class="separator:ga56e335b203e5f8d441f4a334b2b3be8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c0703adcef0d6e6c1a35f44c357a24" id="r_ga93c0703adcef0d6e6c1a35f44c357a24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#ga93c0703adcef0d6e6c1a35f44c357a24">floating</a> = double</td></tr>
<tr class="memdesc:ga93c0703adcef0d6e6c1a35f44c357a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double-precision floating-point type.  <br /></td></tr>
<tr class="separator:ga93c0703adcef0d6e6c1a35f44c357a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97e5374482de5baaded9620b95d5351" id="r_gab97e5374482de5baaded9620b95d5351"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TypeDefinitions.html#gab97e5374482de5baaded9620b95d5351">l_floating</a> = long double</td></tr>
<tr class="memdesc:gab97e5374482de5baaded9620b95d5351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended precision floating-point type.  <br /></td></tr>
<tr class="separator:gab97e5374482de5baaded9620b95d5351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4b8378a065c36e0724269370f084e7" id="r_aaf4b8378a065c36e0724269370f084e7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> N&gt; </td></tr>
<tr class="memitem:aaf4b8378a065c36e0724269370f084e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aaf4b8378a065c36e0724269370f084e7">makeReverseSequence</a> = decltype(<a class="el" href="namespaceoriginal.html#a4e51ab2bbc2425bdb4429bd3b2e87a14">reverseIndexSequenceImpl</a>(<a class="el" href="namespaceoriginal.html#a28819b16311a1c88f678fdec1055a719">makeSequence</a>&lt; N &gt;()))</td></tr>
<tr class="memdesc:aaf4b8378a065c36e0724269370f084e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reversed index sequence.  <br /></td></tr>
<tr class="separator:aaf4b8378a065c36e0724269370f084e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8dc21f8c884d90b6204bcd6890033aa6" id="r_a8dc21f8c884d90b6204bcd6890033aa6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DER , typename DEL &gt; </td></tr>
<tr class="memitem:a8dc21f8c884d90b6204bcd6890033aa6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a8dc21f8c884d90b6204bcd6890033aa6">operator==</a> (const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr, const std::nullptr_t &amp;null)</td></tr>
<tr class="memdesc:a8dc21f8c884d90b6204bcd6890033aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with nullptr.  <br /></td></tr>
<tr class="separator:a8dc21f8c884d90b6204bcd6890033aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abd88507c603855fa51d10a83c73dbb" id="r_a6abd88507c603855fa51d10a83c73dbb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DER , typename DEL &gt; </td></tr>
<tr class="memitem:a6abd88507c603855fa51d10a83c73dbb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a6abd88507c603855fa51d10a83c73dbb">operator!=</a> (const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr, const std::nullptr_t &amp;null)</td></tr>
<tr class="memdesc:a6abd88507c603855fa51d10a83c73dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with nullptr.  <br /></td></tr>
<tr class="separator:a6abd88507c603855fa51d10a83c73dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58f360a00f6b41e2f064a4b6c0c6421" id="r_ae58f360a00f6b41e2f064a4b6c0c6421"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DER , typename DEL &gt; </td></tr>
<tr class="memitem:ae58f360a00f6b41e2f064a4b6c0c6421"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae58f360a00f6b41e2f064a4b6c0c6421">operator==</a> (const std::nullptr_t &amp;null, const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ae58f360a00f6b41e2f064a4b6c0c6421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison with nullptr (reversed operands)  <br /></td></tr>
<tr class="separator:ae58f360a00f6b41e2f064a4b6c0c6421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2667642f0077e1d94fbeaafcd8cf376f" id="r_a2667642f0077e1d94fbeaafcd8cf376f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DER , typename DEL &gt; </td></tr>
<tr class="memitem:a2667642f0077e1d94fbeaafcd8cf376f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a2667642f0077e1d94fbeaafcd8cf376f">operator!=</a> (const std::nullptr_t &amp;null, const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a2667642f0077e1d94fbeaafcd8cf376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison with nullptr (reversed operands)  <br /></td></tr>
<tr class="separator:a2667642f0077e1d94fbeaafcd8cf376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2fc6dcf8fe5e54dd7bafdb775e2398" id="r_aab2fc6dcf8fe5e54dd7bafdb775e2398"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_ &gt; </td></tr>
<tr class="memitem:aab2fc6dcf8fe5e54dd7bafdb775e2398"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aab2fc6dcf8fe5e54dd7bafdb775e2398">operator&amp;</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;lbs, const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;rbs)</td></tr>
<tr class="separator:aab2fc6dcf8fe5e54dd7bafdb775e2398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4af4e6831bcb96b1bfa50c9680e1459" id="r_ab4af4e6831bcb96b1bfa50c9680e1459"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_ &gt; </td></tr>
<tr class="memitem:ab4af4e6831bcb96b1bfa50c9680e1459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ab4af4e6831bcb96b1bfa50c9680e1459">operator|</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;lbs, const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;rbs)</td></tr>
<tr class="separator:ab4af4e6831bcb96b1bfa50c9680e1459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ec502e77d87595609396f9bae2a62" id="r_a696ec502e77d87595609396f9bae2a62"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_ &gt; </td></tr>
<tr class="memitem:a696ec502e77d87595609396f9bae2a62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a696ec502e77d87595609396f9bae2a62">operator^</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;lbs, const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;rbs)</td></tr>
<tr class="separator:a696ec502e77d87595609396f9bae2a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d181a8e2dbc5b413f5484c4cf44da" id="r_a7c9d181a8e2dbc5b413f5484c4cf44da"><td class="memTemplParams" colspan="2">template&lt;typename ALLOC_ &gt; </td></tr>
<tr class="memitem:a7c9d181a8e2dbc5b413f5484c4cf44da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a7c9d181a8e2dbc5b413f5484c4cf44da">operator~</a> (const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;bs)</td></tr>
<tr class="separator:a7c9d181a8e2dbc5b413f5484c4cf44da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c3e467291a99c8f7ca35be430e6f35" id="r_ga26c3e467291a99c8f7ca35be430e6f35"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#ga26c3e467291a99c8f7ca35be430e6f35">ON_WINDOWS</a> ()</td></tr>
<tr class="memdesc:ga26c3e467291a99c8f7ca35be430e6f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for Windows platform.  <br /></td></tr>
<tr class="separator:ga26c3e467291a99c8f7ca35be430e6f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701fa81dff09f72bc10080d2795f37db" id="r_ga701fa81dff09f72bc10080d2795f37db"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#ga701fa81dff09f72bc10080d2795f37db">ON_WIN32</a> ()</td></tr>
<tr class="memdesc:ga701fa81dff09f72bc10080d2795f37db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for 32-bit Windows.  <br /></td></tr>
<tr class="separator:ga701fa81dff09f72bc10080d2795f37db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8ce9444be604d41a61b6ddc6c2e50e" id="r_gaaf8ce9444be604d41a61b6ddc6c2e50e"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#gaaf8ce9444be604d41a61b6ddc6c2e50e">ON_WIN64</a> ()</td></tr>
<tr class="memdesc:gaaf8ce9444be604d41a61b6ddc6c2e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for 64-bit Windows.  <br /></td></tr>
<tr class="separator:gaaf8ce9444be604d41a61b6ddc6c2e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e0a3728187ebd9f29ada2fdbc316a5" id="r_ga16e0a3728187ebd9f29ada2fdbc316a5"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#ga16e0a3728187ebd9f29ada2fdbc316a5">ON_LINUX</a> ()</td></tr>
<tr class="memdesc:ga16e0a3728187ebd9f29ada2fdbc316a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for Linux platform.  <br /></td></tr>
<tr class="separator:ga16e0a3728187ebd9f29ada2fdbc316a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b951ab287cd2ad250184685d9e150a" id="r_gad8b951ab287cd2ad250184685d9e150a"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#gad8b951ab287cd2ad250184685d9e150a">ON_MACOS</a> ()</td></tr>
<tr class="memdesc:gad8b951ab287cd2ad250184685d9e150a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for macOS platform.  <br /></td></tr>
<tr class="separator:gad8b951ab287cd2ad250184685d9e150a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4137960069ec47ef5a21867a3c2ee032" id="r_ga4137960069ec47ef5a21867a3c2ee032"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#ga4137960069ec47ef5a21867a3c2ee032">ON_UNIX</a> ()</td></tr>
<tr class="memdesc:ga4137960069ec47ef5a21867a3c2ee032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for Unix-like platform (excluding Linux/macOS)  <br /></td></tr>
<tr class="separator:ga4137960069ec47ef5a21867a3c2ee032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e815fddb7fde8b8d6e7fc11542f337a" id="r_ga9e815fddb7fde8b8d6e7fc11542f337a"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PlatformDetectionFunctions.html#ga9e815fddb7fde8b8d6e7fc11542f337a">ON_UNKNOWN_PLATFORM</a> ()</td></tr>
<tr class="memdesc:ga9e815fddb7fde8b8d6e7fc11542f337a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling for unknown platform.  <br /></td></tr>
<tr class="separator:ga9e815fddb7fde8b8d6e7fc11542f337a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1fe4d59f4c8bdd29fb66092bf3aeea5" id="r_gae1fe4d59f4c8bdd29fb66092bf3aeea5"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CompilerDetectionFunctions.html#gae1fe4d59f4c8bdd29fb66092bf3aeea5">USING_CLANG</a> ()</td></tr>
<tr class="memdesc:gae1fe4d59f4c8bdd29fb66092bf3aeea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling with Clang.  <br /></td></tr>
<tr class="separator:gae1fe4d59f4c8bdd29fb66092bf3aeea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9028c217e1e04c3cba2787ee5d6ff10e" id="r_ga9028c217e1e04c3cba2787ee5d6ff10e"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CompilerDetectionFunctions.html#ga9028c217e1e04c3cba2787ee5d6ff10e">USING_GCC</a> ()</td></tr>
<tr class="memdesc:ga9028c217e1e04c3cba2787ee5d6ff10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling with GCC.  <br /></td></tr>
<tr class="separator:ga9028c217e1e04c3cba2787ee5d6ff10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8db2d7096478a5d6fc4095838096824a" id="r_ga8db2d7096478a5d6fc4095838096824a"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CompilerDetectionFunctions.html#ga8db2d7096478a5d6fc4095838096824a">USING_MSVC</a> ()</td></tr>
<tr class="memdesc:ga8db2d7096478a5d6fc4095838096824a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling with MSVC.  <br /></td></tr>
<tr class="separator:ga8db2d7096478a5d6fc4095838096824a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3434add3f2a4cc26641217316914da7d" id="r_ga3434add3f2a4cc26641217316914da7d"><td class="memItemLeft" align="right" valign="top">consteval bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CompilerDetectionFunctions.html#ga3434add3f2a4cc26641217316914da7d">USING_UNKNOWN_COMPLIER</a> ()</td></tr>
<tr class="memdesc:ga3434add3f2a4cc26641217316914da7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if compiling with unknown compiler.  <br /></td></tr>
<tr class="separator:ga3434add3f2a4cc26641217316914da7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db8c31a0d9119ae22cc0ee854023eb4" id="r_a1db8c31a0d9119ae22cc0ee854023eb4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1db8c31a0d9119ae22cc0ee854023eb4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a1db8c31a0d9119ae22cc0ee854023eb4">operator&amp;&amp;</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f1, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f2)</td></tr>
<tr class="memdesc:a1db8c31a0d9119ae22cc0ee854023eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create AND <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters.  <br /></td></tr>
<tr class="separator:a1db8c31a0d9119ae22cc0ee854023eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9161566f8b79c18b9f7d44716e71ae" id="r_a1f9161566f8b79c18b9f7d44716e71ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f9161566f8b79c18b9f7d44716e71ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a1f9161566f8b79c18b9f7d44716e71ae">operator&amp;&amp;</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f, const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:a1f9161566f8b79c18b9f7d44716e71ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>.  <br /></td></tr>
<tr class="separator:a1f9161566f8b79c18b9f7d44716e71ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c593192f7fe4c1d14e221fe9407369" id="r_a32c593192f7fe4c1d14e221fe9407369"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32c593192f7fe4c1d14e221fe9407369"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a32c593192f7fe4c1d14e221fe9407369">operator&amp;&amp;</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:a32c593192f7fe4c1d14e221fe9407369"><td class="mdescLeft">&#160;</td><td class="mdescRight">AND operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter.  <br /></td></tr>
<tr class="separator:a32c593192f7fe4c1d14e221fe9407369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5022994e6fe02721e521a9a0edf56901" id="r_a5022994e6fe02721e521a9a0edf56901"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5022994e6fe02721e521a9a0edf56901"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a5022994e6fe02721e521a9a0edf56901">operator||</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f1, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f2)</td></tr>
<tr class="memdesc:a5022994e6fe02721e521a9a0edf56901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create OR <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters.  <br /></td></tr>
<tr class="separator:a5022994e6fe02721e521a9a0edf56901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211e12b568c0705c118b16616ea931ef" id="r_a211e12b568c0705c118b16616ea931ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a211e12b568c0705c118b16616ea931ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a211e12b568c0705c118b16616ea931ef">operator||</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f, const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:a211e12b568c0705c118b16616ea931ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>.  <br /></td></tr>
<tr class="separator:a211e12b568c0705c118b16616ea931ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b99c956ab1ee40f5b50ec2422e5c7d9" id="r_a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a9b99c956ab1ee40f5b50ec2422e5c7d9">operator||</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs, const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OR operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter.  <br /></td></tr>
<tr class="separator:a9b99c956ab1ee40f5b50ec2422e5c7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb35d1af29a0c0be3a17081b9ca9dd0" id="r_a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a1fb35d1af29a0c0be3a17081b9ca9dd0">operator!</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from filter.  <br /></td></tr>
<tr class="separator:a1fb35d1af29a0c0be3a17081b9ca9dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74fe2f9ca0a3e0a5dc33272f50e56e8" id="r_ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ad74fe2f9ca0a3e0a5dc33272f50e56e8">operator!</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream.  <br /></td></tr>
<tr class="separator:ad74fe2f9ca0a3e0a5dc33272f50e56e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ae231e8e4a92af1e9f3940f249c70" id="r_acd6ae231e8e4a92af1e9f3940f249c70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd6ae231e8e4a92af1e9f3940f249c70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#acd6ae231e8e4a92af1e9f3940f249c70">group</a> (const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;ofs)</td></tr>
<tr class="memdesc:acd6ae231e8e4a92af1e9f3940f249c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream.  <br /></td></tr>
<tr class="separator:acd6ae231e8e4a92af1e9f3940f249c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc95f4b01319d7d40643c55df213e3d" id="r_abcc95f4b01319d7d40643c55df213e3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcc95f4b01319d7d40643c55df213e3d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#abcc95f4b01319d7d40643c55df213e3d">group</a> (const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;f)</td></tr>
<tr class="memdesc:abcc95f4b01319d7d40643c55df213e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from single filter.  <br /></td></tr>
<tr class="separator:abcc95f4b01319d7d40643c55df213e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176d8ed479959a50d637c2ee6900a159" id="r_a176d8ed479959a50d637c2ee6900a159"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a176d8ed479959a50d637c2ee6900a159"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a176d8ed479959a50d637c2ee6900a159">operator+</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;it, <a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> steps) -&gt; <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *</td></tr>
<tr class="memdesc:a176d8ed479959a50d637c2ee6900a159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a number of steps to the iterator's current position and returns a new iterator.  <br /></td></tr>
<tr class="separator:a176d8ed479959a50d637c2ee6900a159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e78d5e4c7f280f178b3812298ef44b3" id="r_a2e78d5e4c7f280f178b3812298ef44b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e78d5e4c7f280f178b3812298ef44b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a2e78d5e4c7f280f178b3812298ef44b3">operator-</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;it, <a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> steps) -&gt; <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *</td></tr>
<tr class="memdesc:a2e78d5e4c7f280f178b3812298ef44b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts a number of steps from the iterator's current position and returns a new iterator.  <br /></td></tr>
<tr class="separator:a2e78d5e4c7f280f178b3812298ef44b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe93d9c1453d7be3fa90077fd1b8f03" id="r_aebe93d9c1453d7be3fa90077fd1b8f03"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebe93d9c1453d7be3fa90077fd1b8f03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aebe93d9c1453d7be3fa90077fd1b8f03">operator==</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;l_it, const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;r_it)</td></tr>
<tr class="memdesc:aebe93d9c1453d7be3fa90077fd1b8f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison operator for iterators.  <br /></td></tr>
<tr class="separator:aebe93d9c1453d7be3fa90077fd1b8f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d01647f32db1756ca882182fd605d88" id="r_a1d01647f32db1756ca882182fd605d88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d01647f32db1756ca882182fd605d88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a1d01647f32db1756ca882182fd605d88">operator!=</a> (const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;l_it, const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;r_it)</td></tr>
<tr class="memdesc:a1d01647f32db1756ca882182fd605d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison operator for iterators.  <br /></td></tr>
<tr class="separator:a1d01647f32db1756ca882182fd605d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303822f1cf65f29a40abc3883f0fb138" id="r_a303822f1cf65f29a40abc3883f0fb138"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a303822f1cf65f29a40abc3883f0fb138"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a303822f1cf65f29a40abc3883f0fb138">abs</a> (TYPE a)</td></tr>
<tr class="memdesc:a303822f1cf65f29a40abc3883f0fb138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a given number.  <br /></td></tr>
<tr class="separator:a303822f1cf65f29a40abc3883f0fb138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f42f26b6aa61acc458a6bfd9c49581f" id="r_a0f42f26b6aa61acc458a6bfd9c49581f"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a0f42f26b6aa61acc458a6bfd9c49581f"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a0f42f26b6aa61acc458a6bfd9c49581f">max</a> (TYPE a, TYPE b)</td></tr>
<tr class="memdesc:a0f42f26b6aa61acc458a6bfd9c49581f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of two given values.  <br /></td></tr>
<tr class="separator:a0f42f26b6aa61acc458a6bfd9c49581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d69e120da2a56a2e72fc9834edfb0ec" id="r_a0d69e120da2a56a2e72fc9834edfb0ec"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a0d69e120da2a56a2e72fc9834edfb0ec"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a0d69e120da2a56a2e72fc9834edfb0ec">min</a> (TYPE a, TYPE b)</td></tr>
<tr class="memdesc:a0d69e120da2a56a2e72fc9834edfb0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of two given values.  <br /></td></tr>
<tr class="separator:a0d69e120da2a56a2e72fc9834edfb0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c4cc6e557e2b2a8d86f3ec463ab20a" id="r_ac9c4cc6e557e2b2a8d86f3ec463ab20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__TypeDefinitions.html#ga93c0703adcef0d6e6c1a35f44c357a24">floating</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ac9c4cc6e557e2b2a8d86f3ec463ab20a">pow</a> (<a class="el" href="group__TypeDefinitions.html#ga93c0703adcef0d6e6c1a35f44c357a24">floating</a> base, <a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> exp)</td></tr>
<tr class="memdesc:ac9c4cc6e557e2b2a8d86f3ec463ab20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of raising a base to an exponent.  <br /></td></tr>
<tr class="separator:ac9c4cc6e557e2b2a8d86f3ec463ab20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17552f40eb8b0c25f10f54d13fcf6c2e" id="r_a17552f40eb8b0c25f10f54d13fcf6c2e"><td class="memTemplParams" colspan="2">template&lt;std::integral INTEGER = int&gt; </td></tr>
<tr class="memitem:a17552f40eb8b0c25f10f54d13fcf6c2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; INTEGER &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a17552f40eb8b0c25f10f54d13fcf6c2e">rangesOf</a> (INTEGER start, INTEGER end, INTEGER steps=1)</td></tr>
<tr class="memdesc:a17552f40eb8b0c25f10f54d13fcf6c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence of integers from <code>start</code> to <code>end</code> (exclusive) with a given <code>steps</code>.  <br /></td></tr>
<tr class="separator:a17552f40eb8b0c25f10f54d13fcf6c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bebb9ab61ff7783b0fb2c90704246a1" id="r_a5bebb9ab61ff7783b0fb2c90704246a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DEL  = deleter&lt;T&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a5bebb9ab61ff7783b0fb2c90704246a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a5bebb9ab61ff7783b0fb2c90704246a1">makeOwnerPtr</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5bebb9ab61ff7783b0fb2c90704246a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated object.  <br /></td></tr>
<tr class="separator:a5bebb9ab61ff7783b0fb2c90704246a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c2ad6f571fb457b96abd1ab2dd660f" id="r_a84c2ad6f571fb457b96abd1ab2dd660f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DEL  = deleter&lt;T[]&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a84c2ad6f571fb457b96abd1ab2dd660f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a84c2ad6f571fb457b96abd1ab2dd660f">makeOwnerPtrArray</a> (<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> size, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a84c2ad6f571fb457b96abd1ab2dd660f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated array.  <br /></td></tr>
<tr class="separator:a84c2ad6f571fb457b96abd1ab2dd660f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf3733f8dbb6afdb7c4b4559c262da4" id="r_a6bf3733f8dbb6afdb7c4b4559c262da4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a6bf3733f8dbb6afdb7c4b4559c262da4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classoriginal_1_1printable.html">printable</a> &amp;p)</td></tr>
<tr class="memdesc:a6bf3733f8dbb6afdb7c4b4559c262da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream insertion operator for printable objects.  <br /></td></tr>
<tr class="separator:a6bf3733f8dbb6afdb7c4b4559c262da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a918750a407487641ef6924df40d8d" id="r_ab3a918750a407487641ef6924df40d8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DEL  = deleter&lt;T&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:ab3a918750a407487641ef6924df40d8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ab3a918750a407487641ef6924df40d8d">makeStrongPtr</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab3a918750a407487641ef6924df40d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared object.  <br /></td></tr>
<tr class="separator:ab3a918750a407487641ef6924df40d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70101a33a2bf1305a42a180652c98c95" id="r_a70101a33a2bf1305a42a180652c98c95"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DEL  = deleter&lt;T[]&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a70101a33a2bf1305a42a180652c98c95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a70101a33a2bf1305a42a180652c98c95">makeStrongPtrArray</a> (<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> size, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a70101a33a2bf1305a42a180652c98c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared array.  <br /></td></tr>
<tr class="separator:a70101a33a2bf1305a42a180652c98c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a26f512ed3d73721da23b1f19437f6" id="r_a38a26f512ed3d73721da23b1f19437f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38a26f512ed3d73721da23b1f19437f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a38a26f512ed3d73721da23b1f19437f6">operator+</a> (const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;t1, const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;t2)</td></tr>
<tr class="memdesc:a38a26f512ed3d73721da23b1f19437f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new transformation stream from two transforms.  <br /></td></tr>
<tr class="separator:a38a26f512ed3d73721da23b1f19437f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47ef543dcb851270ddb7b59ae4ae103" id="r_ae47ef543dcb851270ddb7b59ae4ae103"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae47ef543dcb851270ddb7b59ae4ae103"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae47ef543dcb851270ddb7b59ae4ae103">operator+</a> (const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;t, const <a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; &amp;ots)</td></tr>
<tr class="memdesc:ae47ef543dcb851270ddb7b59ae4ae103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new stream by prefixing existing stream.  <br /></td></tr>
<tr class="separator:ae47ef543dcb851270ddb7b59ae4ae103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825c5ff9d360f357bff2e67f0191b5d8" id="r_a825c5ff9d360f357bff2e67f0191b5d8"><td class="memTemplParams" colspan="2"><a id="a825c5ff9d360f357bff2e67f0191b5d8" name="a825c5ff9d360f357bff2e67f0191b5d8"></a>
template&lt;typename F_TYPE , typename S_TYPE &gt; </td></tr>
<tr class="memitem:a825c5ff9d360f357bff2e67f0191b5d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; F_TYPE, S_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTuple</b> (const <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; F_TYPE, S_TYPE &gt; &amp;cp)</td></tr>
<tr class="separator:a825c5ff9d360f357bff2e67f0191b5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e861489ea083e67fe482719ce5980e1" id="r_a1e861489ea083e67fe482719ce5980e1"><td class="memTemplParams" colspan="2"><a id="a1e861489ea083e67fe482719ce5980e1" name="a1e861489ea083e67fe482719ce5980e1"></a>
template&lt;typename F_TYPE , typename S_TYPE &gt; </td></tr>
<tr class="memitem:a1e861489ea083e67fe482719ce5980e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1tuple.html">tuple</a>&lt; F_TYPE, S_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTuple</b> (<a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; F_TYPE, S_TYPE &gt; &amp;&amp;cp)</td></tr>
<tr class="separator:a1e861489ea083e67fe482719ce5980e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28819b16311a1c88f678fdec1055a719" id="r_a28819b16311a1c88f678fdec1055a719"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> NUM&gt; </td></tr>
<tr class="memitem:a28819b16311a1c88f678fdec1055a719"><td class="memTemplItemLeft" align="right" valign="top">consteval auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a28819b16311a1c88f678fdec1055a719">makeSequence</a> () noexcept</td></tr>
<tr class="memdesc:a28819b16311a1c88f678fdec1055a719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an index sequence of given length.  <br /></td></tr>
<tr class="separator:a28819b16311a1c88f678fdec1055a719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e51ab2bbc2425bdb4429bd3b2e87a14" id="r_a4e51ab2bbc2425bdb4429bd3b2e87a14"><td class="memTemplParams" colspan="2">template&lt;u_integer... Indices&gt; </td></tr>
<tr class="memitem:a4e51ab2bbc2425bdb4429bd3b2e87a14"><td class="memTemplItemLeft" align="right" valign="top">consteval auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a4e51ab2bbc2425bdb4429bd3b2e87a14">reverseIndexSequenceImpl</a> (<a class="el" href="classoriginal_1_1indexSequence.html">indexSequence</a>&lt; Indices... &gt; seq)</td></tr>
<tr class="memdesc:a4e51ab2bbc2425bdb4429bd3b2e87a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation detail for reversing an index sequence.  <br /></td></tr>
<tr class="separator:a4e51ab2bbc2425bdb4429bd3b2e87a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e165ce51196867f11455bc2a445c1f" id="r_a14e165ce51196867f11455bc2a445c1f"><td class="memTemplParams" colspan="2"><a id="a14e165ce51196867f11455bc2a445c1f" name="a14e165ce51196867f11455bc2a445c1f"></a>
template&lt;typename T , typename... ARGS&gt; </td></tr>
<tr class="memitem:a14e165ce51196867f11455bc2a445c1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1vector.html">vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeVector</b> (<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> size, ARGS &amp;&amp;... args)</td></tr>
<tr class="separator:a14e165ce51196867f11455bc2a445c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba3c2d7cc56cc45d532cca8f22dd2c1" id="r_aeba3c2d7cc56cc45d532cca8f22dd2c1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callback &gt; </td></tr>
<tr class="memitem:aeba3c2d7cc56cc45d532cca8f22dd2c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aeba3c2d7cc56cc45d532cca8f22dd2c1">operator|</a> (<a class="el" href="classoriginal_1_1async_1_1future.html">async::future</a>&lt; T &gt; f, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:aeba3c2d7cc56cc45d532cca8f22dd2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator for chaining asynchronous computations.  <br /></td></tr>
<tr class="separator:aeba3c2d7cc56cc45d532cca8f22dd2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72f04021dc08546003a51eae52bc8a7" id="r_ae72f04021dc08546003a51eae52bc8a7"><td class="memTemplParams" colspan="2">template&lt;typename Callback &gt; </td></tr>
<tr class="memitem:ae72f04021dc08546003a51eae52bc8a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae72f04021dc08546003a51eae52bc8a7">operator|</a> (<a class="el" href="classoriginal_1_1async_1_1future.html">async::future</a>&lt; void &gt; f, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:ae72f04021dc08546003a51eae52bc8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator specialization for future&lt;void&gt;  <br /></td></tr>
<tr class="separator:ae72f04021dc08546003a51eae52bc8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c010dbb900d7462ab212169ff78e0" id="r_a331c010dbb900d7462ab212169ff78e0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callback &gt; </td></tr>
<tr class="memitem:a331c010dbb900d7462ab212169ff78e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a331c010dbb900d7462ab212169ff78e0">operator|</a> (<a class="el" href="classoriginal_1_1async_1_1sharedFuture.html">async::sharedFuture</a>&lt; T &gt; sf, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a331c010dbb900d7462ab212169ff78e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator for chaining computations on sharedFuture.  <br /></td></tr>
<tr class="separator:a331c010dbb900d7462ab212169ff78e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8799c0ea3948308bfc84b56f2c7b6cbe" id="r_a8799c0ea3948308bfc84b56f2c7b6cbe"><td class="memTemplParams" colspan="2">template&lt;typename Callback &gt; </td></tr>
<tr class="memitem:a8799c0ea3948308bfc84b56f2c7b6cbe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a8799c0ea3948308bfc84b56f2c7b6cbe">operator|</a> (<a class="el" href="classoriginal_1_1async_1_1sharedFuture.html">async::sharedFuture</a>&lt; void &gt; sf, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a8799c0ea3948308bfc84b56f2c7b6cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator specialization for sharedFuture&lt;void&gt;  <br /></td></tr>
<tr class="separator:a8799c0ea3948308bfc84b56f2c7b6cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55282b584ea2c4a589d358e60e98efe5" id="r_a55282b584ea2c4a589d358e60e98efe5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Callback1 , typename Callback2 &gt; </td></tr>
<tr class="memitem:a55282b584ea2c4a589d358e60e98efe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a55282b584ea2c4a589d358e60e98efe5">operator|</a> (<a class="el" href="classoriginal_1_1async_1_1promise.html">async::promise</a>&lt; T, Callback1 &gt; p, Callback2 &amp;&amp;c)</td></tr>
<tr class="memdesc:a55282b584ea2c4a589d358e60e98efe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy pipe operator for chaining promise computations.  <br /></td></tr>
<tr class="separator:a55282b584ea2c4a589d358e60e98efe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e54e02f38ce013d7568d2353cfc0fff" id="r_a4e54e02f38ce013d7568d2353cfc0fff"><td class="memTemplParams" colspan="2">template&lt;typename Callback1 , typename Callback2 &gt; </td></tr>
<tr class="memitem:a4e54e02f38ce013d7568d2353cfc0fff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a4e54e02f38ce013d7568d2353cfc0fff">operator|</a> (<a class="el" href="classoriginal_1_1async_1_1promise.html">async::promise</a>&lt; void, Callback1 &gt; p, Callback2 &amp;&amp;c)</td></tr>
<tr class="memdesc:a4e54e02f38ce013d7568d2353cfc0fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lazy pipe operator specialization for promise&lt;void&gt;  <br /></td></tr>
<tr class="separator:a4e54e02f38ce013d7568d2353cfc0fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c54968b94a7b8bd4f4b1737928ba785" id="r_a8c54968b94a7b8bd4f4b1737928ba785"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a8c54968b94a7b8bd4f4b1737928ba785"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; <a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>, TYPE &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a8c54968b94a7b8bd4f4b1737928ba785">enumerate</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen)</td></tr>
<tr class="memdesc:a8c54968b94a7b8bd4f4b1737928ba785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates elements of a generator with their indices.  <br /></td></tr>
<tr class="separator:a8c54968b94a7b8bd4f4b1737928ba785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b1d89c1b09d143f3c13841db69bbb8" id="r_ab9b1d89c1b09d143f3c13841db69bbb8"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename SET  = hashSet&lt;TYPE&gt;&gt; <br />
requires ExtendsOf&lt;<a class="el" href="classoriginal_1_1set.html">set</a>&lt;TYPE, <a class="el" href="classoriginal_1_1allocator.html">allocator</a>&lt;<a class="el" href="classoriginal_1_1couple.html">couple</a>&lt;const TYPE, const bool&gt;&gt;&gt;, SET&gt;</td></tr>
<tr class="memitem:ab9b1d89c1b09d143f3c13841db69bbb8"><td class="memTemplItemLeft" align="right" valign="top">SET&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ab9b1d89c1b09d143f3c13841db69bbb8">collect</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen)</td></tr>
<tr class="memdesc:ab9b1d89c1b09d143f3c13841db69bbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects generator elements into a set.  <br /></td></tr>
<tr class="separator:ab9b1d89c1b09d143f3c13841db69bbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec02bedf05dad00be37632abf5d63f3" id="r_aeec02bedf05dad00be37632abf5d63f3"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , template&lt; typename &gt; typename SERIAL = vector&gt; <br />
requires ExtendsOf&lt;<a class="el" href="classoriginal_1_1baseList.html">baseList</a>&lt;TYPE, <a class="el" href="classoriginal_1_1allocator.html">allocator</a>&lt;TYPE&gt;&gt;, SERIAL&lt;TYPE&gt;&gt;</td></tr>
<tr class="memitem:aeec02bedf05dad00be37632abf5d63f3"><td class="memTemplItemLeft" align="right" valign="top">SERIAL&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aeec02bedf05dad00be37632abf5d63f3">list</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen)</td></tr>
<tr class="memdesc:aeec02bedf05dad00be37632abf5d63f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects generator elements into a list container.  <br /></td></tr>
<tr class="separator:aeec02bedf05dad00be37632abf5d63f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2944d86814f3187bc93fcba4dcc9ad" id="r_aba2944d86814f3187bc93fcba4dcc9ad"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:aba2944d86814f3187bc93fcba4dcc9ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aba2944d86814f3187bc93fcba4dcc9ad">transforms</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c) -&gt; <a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; std::invoke_result_t&lt; Callback, TYPE &gt; &gt;</td></tr>
<tr class="memdesc:aba2944d86814f3187bc93fcba4dcc9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms generator elements using a callable.  <br /></td></tr>
<tr class="separator:aba2944d86814f3187bc93fcba4dcc9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb963df451f2091ae65a71e792c96a5" id="r_a3bb963df451f2091ae65a71e792c96a5"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:a3bb963df451f2091ae65a71e792c96a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a3bb963df451f2091ae65a71e792c96a5">filters</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a3bb963df451f2091ae65a71e792c96a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters generator elements based on a predicate.  <br /></td></tr>
<tr class="separator:a3bb963df451f2091ae65a71e792c96a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412484dedc20d4058afc716f9da12ef0" id="r_a412484dedc20d4058afc716f9da12ef0"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:a412484dedc20d4058afc716f9da12ef0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a412484dedc20d4058afc716f9da12ef0">extract</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a412484dedc20d4058afc716f9da12ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts elements that do not satisfy a predicate.  <br /></td></tr>
<tr class="separator:a412484dedc20d4058afc716f9da12ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c7c44f58fe2c19b44736b606159f8d" id="r_ae0c7c44f58fe2c19b44736b606159f8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae0c7c44f58fe2c19b44736b606159f8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; T, U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae0c7c44f58fe2c19b44736b606159f8d">zip</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt; gen1, <a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt; gen2)</td></tr>
<tr class="memdesc:ae0c7c44f58fe2c19b44736b606159f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips two generators into pairs.  <br /></td></tr>
<tr class="separator:ae0c7c44f58fe2c19b44736b606159f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666b26e94abdc060e75dfbba14460615" id="r_a666b26e94abdc060e75dfbba14460615"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a666b26e94abdc060e75dfbba14460615"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a666b26e94abdc060e75dfbba14460615">count</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen)</td></tr>
<tr class="memdesc:a666b26e94abdc060e75dfbba14460615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts total elements in a generator.  <br /></td></tr>
<tr class="separator:a666b26e94abdc060e75dfbba14460615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4508803490d4901c5a7ebb4db260586" id="r_aa4508803490d4901c5a7ebb4db260586"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:aa4508803490d4901c5a7ebb4db260586"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aa4508803490d4901c5a7ebb4db260586">count</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:aa4508803490d4901c5a7ebb4db260586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts elements satisfying a predicate.  <br /></td></tr>
<tr class="separator:aa4508803490d4901c5a7ebb4db260586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2627c05d6a11986955cbd84456d08d90" id="r_a2627c05d6a11986955cbd84456d08d90"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:a2627c05d6a11986955cbd84456d08d90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a2627c05d6a11986955cbd84456d08d90">all</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a2627c05d6a11986955cbd84456d08d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements satisfy a predicate.  <br /></td></tr>
<tr class="separator:a2627c05d6a11986955cbd84456d08d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0132dd122c3a7025a465c7b8aacf9a3" id="r_ae0132dd122c3a7025a465c7b8aacf9a3"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:ae0132dd122c3a7025a465c7b8aacf9a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae0132dd122c3a7025a465c7b8aacf9a3">none</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:ae0132dd122c3a7025a465c7b8aacf9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if no elements satisfy a predicate.  <br /></td></tr>
<tr class="separator:ae0132dd122c3a7025a465c7b8aacf9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7fe159de2af67c79de5feffadad2a9" id="r_aeb7fe159de2af67c79de5feffadad2a9"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:aeb7fe159de2af67c79de5feffadad2a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aeb7fe159de2af67c79de5feffadad2a9">any</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:aeb7fe159de2af67c79de5feffadad2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any element satisfies a predicate.  <br /></td></tr>
<tr class="separator:aeb7fe159de2af67c79de5feffadad2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318cbbdd897afa6e01dd427c9ed8b2b1" id="r_a318cbbdd897afa6e01dd427c9ed8b2b1"><td class="memTemplParams" colspan="2">template&lt;typename T , std::convertible_to&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:a318cbbdd897afa6e01dd427c9ed8b2b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a318cbbdd897afa6e01dd427c9ed8b2b1">join</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt; gen1, <a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt; gen2)</td></tr>
<tr class="memdesc:a318cbbdd897afa6e01dd427c9ed8b2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins two generators of compatible types.  <br /></td></tr>
<tr class="separator:a318cbbdd897afa6e01dd427c9ed8b2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9970494c43ee8edd531daa3b67b4eb" id="r_a9a9970494c43ee8edd531daa3b67b4eb"><td class="memTemplParams" colspan="2">template&lt;typename T , std::convertible_to&lt; T &gt; U&gt; </td></tr>
<tr class="memitem:a9a9970494c43ee8edd531daa3b67b4eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a9a9970494c43ee8edd531daa3b67b4eb">flatten</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; T, U &gt; &gt; gen)</td></tr>
<tr class="memdesc:a9a9970494c43ee8edd531daa3b67b4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens a generator of couples into a single generator.  <br /></td></tr>
<tr class="separator:a9a9970494c43ee8edd531daa3b67b4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2702810184338d29e82f22af59d7dbd3" id="r_a2702810184338d29e82f22af59d7dbd3"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a2702810184338d29e82f22af59d7dbd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a2702810184338d29e82f22af59d7dbd3">take</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, <a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> n)</td></tr>
<tr class="memdesc:a2702810184338d29e82f22af59d7dbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the first n elements from a generator.  <br /></td></tr>
<tr class="separator:a2702810184338d29e82f22af59d7dbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ae078f895b8100b5aed3e3b26f156e" id="r_a18ae078f895b8100b5aed3e3b26f156e"><td class="memTemplParams" colspan="2">template&lt;typename TYPE &gt; </td></tr>
<tr class="memitem:a18ae078f895b8100b5aed3e3b26f156e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a18ae078f895b8100b5aed3e3b26f156e">skip</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, <a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> n)</td></tr>
<tr class="memdesc:a18ae078f895b8100b5aed3e3b26f156e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the first n elements of a generator.  <br /></td></tr>
<tr class="separator:a18ae078f895b8100b5aed3e3b26f156e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4527274cfb7fc9519d858ba76cdf0c2f" id="r_a4527274cfb7fc9519d858ba76cdf0c2f"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:a4527274cfb7fc9519d858ba76cdf0c2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a4527274cfb7fc9519d858ba76cdf0c2f">position</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a4527274cfb7fc9519d858ba76cdf0c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first element satisfying a predicate.  <br /></td></tr>
<tr class="separator:a4527274cfb7fc9519d858ba76cdf0c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe065ee79ac890811d903963ec10724" id="r_a2fe065ee79ac890811d903963ec10724"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename Callback &gt; </td></tr>
<tr class="memitem:a2fe065ee79ac890811d903963ec10724"><td class="memTemplItemLeft" align="right" valign="top">TYPE&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a2fe065ee79ac890811d903963ec10724">find</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, Callback &amp;&amp;c)</td></tr>
<tr class="memdesc:a2fe065ee79ac890811d903963ec10724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first element satisfying a predicate.  <br /></td></tr>
<tr class="separator:a2fe065ee79ac890811d903963ec10724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b933d9e66dcd0b8f443fa0c38e122" id="r_ace0b933d9e66dcd0b8f443fa0c38e122"><td class="memTemplParams" colspan="2">template&lt;typename TYPE , typename F &gt; </td></tr>
<tr class="memitem:ace0b933d9e66dcd0b8f443fa0c38e122"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ace0b933d9e66dcd0b8f443fa0c38e122">operator|</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; gen, <a class="el" href="classoriginal_1_1genPipe.html">genPipe</a>&lt; F &gt; p)</td></tr>
<tr class="memdesc:ace0b933d9e66dcd0b8f443fa0c38e122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipe operator for generator operations.  <br /></td></tr>
<tr class="separator:ace0b933d9e66dcd0b8f443fa0c38e122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1671ab76b31ddaa0cb58adae7f23195b" id="r_a1671ab76b31ddaa0cb58adae7f23195b"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a1671ab76b31ddaa0cb58adae7f23195b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a1671ab76b31ddaa0cb58adae7f23195b">transforms</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a1671ab76b31ddaa0cb58adae7f23195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a transform pipe operation.  <br /></td></tr>
<tr class="separator:a1671ab76b31ddaa0cb58adae7f23195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d773c3caafcbede851abef6b93ff8c" id="r_ad1d773c3caafcbede851abef6b93ff8c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ad1d773c3caafcbede851abef6b93ff8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ad1d773c3caafcbede851abef6b93ff8c">filters</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ad1d773c3caafcbede851abef6b93ff8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a filter pipe operation.  <br /></td></tr>
<tr class="separator:ad1d773c3caafcbede851abef6b93ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed9f8b310e05aeaca3de7372dbfed0a" id="r_a5ed9f8b310e05aeaca3de7372dbfed0a"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5ed9f8b310e05aeaca3de7372dbfed0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a5ed9f8b310e05aeaca3de7372dbfed0a">extract</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a5ed9f8b310e05aeaca3de7372dbfed0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an extract pipe operation.  <br /></td></tr>
<tr class="separator:a5ed9f8b310e05aeaca3de7372dbfed0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9420d79ec2ce055dbcee890a66d1b6cc" id="r_a9420d79ec2ce055dbcee890a66d1b6cc"><td class="memTemplParams" colspan="2">template&lt;typename  = void&gt; </td></tr>
<tr class="memitem:a9420d79ec2ce055dbcee890a66d1b6cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a9420d79ec2ce055dbcee890a66d1b6cc">enumerate</a> ()</td></tr>
<tr class="memdesc:a9420d79ec2ce055dbcee890a66d1b6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an enumerate pipe operation.  <br /></td></tr>
<tr class="separator:a9420d79ec2ce055dbcee890a66d1b6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac4116340b45e469d5a889a065643c6" id="r_a7ac4116340b45e469d5a889a065643c6"><td class="memTemplParams" colspan="2">template&lt;typename  = void&gt; </td></tr>
<tr class="memitem:a7ac4116340b45e469d5a889a065643c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a7ac4116340b45e469d5a889a065643c6">take</a> (<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> n)</td></tr>
<tr class="memdesc:a7ac4116340b45e469d5a889a065643c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a take pipe operation.  <br /></td></tr>
<tr class="separator:a7ac4116340b45e469d5a889a065643c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5940d515f98ed643fe39e2579a28cc" id="r_adf5940d515f98ed643fe39e2579a28cc"><td class="memTemplParams" colspan="2">template&lt;typename  = void&gt; </td></tr>
<tr class="memitem:adf5940d515f98ed643fe39e2579a28cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#adf5940d515f98ed643fe39e2579a28cc">skip</a> (<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> n)</td></tr>
<tr class="memdesc:adf5940d515f98ed643fe39e2579a28cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a skip pipe operation.  <br /></td></tr>
<tr class="separator:adf5940d515f98ed643fe39e2579a28cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6b7b3c430ab35988b6ab12d107e0bd" id="r_abc6b7b3c430ab35988b6ab12d107e0bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:abc6b7b3c430ab35988b6ab12d107e0bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#abc6b7b3c430ab35988b6ab12d107e0bd">join</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt; gen2)</td></tr>
<tr class="memdesc:abc6b7b3c430ab35988b6ab12d107e0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a join pipe operation.  <br /></td></tr>
<tr class="separator:abc6b7b3c430ab35988b6ab12d107e0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdceaa66d583b7fc47948a98e3d2478" id="r_aebdceaa66d583b7fc47948a98e3d2478"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aebdceaa66d583b7fc47948a98e3d2478"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aebdceaa66d583b7fc47948a98e3d2478">flatten</a> ()</td></tr>
<tr class="memdesc:aebdceaa66d583b7fc47948a98e3d2478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a flatten pipe operation.  <br /></td></tr>
<tr class="separator:aebdceaa66d583b7fc47948a98e3d2478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d66ded42ac114bcf9d5fd5ea537c0b9" id="r_a2d66ded42ac114bcf9d5fd5ea537c0b9"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2d66ded42ac114bcf9d5fd5ea537c0b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a2d66ded42ac114bcf9d5fd5ea537c0b9">zipWith</a> (<a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt; gen2)</td></tr>
<tr class="memdesc:a2d66ded42ac114bcf9d5fd5ea537c0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a zipWith pipe operation.  <br /></td></tr>
<tr class="separator:a2d66ded42ac114bcf9d5fd5ea537c0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e1ef4e30a4759f6609ea322a59e4c3" id="r_ae9e1ef4e30a4759f6609ea322a59e4c3"><td class="memTemplParams" colspan="2">template&lt;typename  = void&gt; </td></tr>
<tr class="memitem:ae9e1ef4e30a4759f6609ea322a59e4c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae9e1ef4e30a4759f6609ea322a59e4c3">count</a> ()</td></tr>
<tr class="memdesc:ae9e1ef4e30a4759f6609ea322a59e4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a count pipe operation.  <br /></td></tr>
<tr class="separator:ae9e1ef4e30a4759f6609ea322a59e4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f71cd5625a315b1212e21ec8e399f0" id="r_ac6f71cd5625a315b1212e21ec8e399f0"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ac6f71cd5625a315b1212e21ec8e399f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ac6f71cd5625a315b1212e21ec8e399f0">count</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ac6f71cd5625a315b1212e21ec8e399f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a conditional count pipe operation.  <br /></td></tr>
<tr class="separator:ac6f71cd5625a315b1212e21ec8e399f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a83f54429aae10a76283bdef427a44" id="r_a77a83f54429aae10a76283bdef427a44"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a77a83f54429aae10a76283bdef427a44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a77a83f54429aae10a76283bdef427a44">all</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a77a83f54429aae10a76283bdef427a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an all-match pipe operation.  <br /></td></tr>
<tr class="separator:a77a83f54429aae10a76283bdef427a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354ee852b16ecb9f5275b54a2b178c65" id="r_a354ee852b16ecb9f5275b54a2b178c65"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a354ee852b16ecb9f5275b54a2b178c65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a354ee852b16ecb9f5275b54a2b178c65">none</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a354ee852b16ecb9f5275b54a2b178c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a none-match pipe operation.  <br /></td></tr>
<tr class="separator:a354ee852b16ecb9f5275b54a2b178c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa756154f45cd9f39510c3c236167c39d" id="r_aa756154f45cd9f39510c3c236167c39d"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aa756154f45cd9f39510c3c236167c39d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aa756154f45cd9f39510c3c236167c39d">any</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:aa756154f45cd9f39510c3c236167c39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an any-match pipe operation.  <br /></td></tr>
<tr class="separator:aa756154f45cd9f39510c3c236167c39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba1d14dd3063cd86d2b28662b0de1d" id="r_ab1ba1d14dd3063cd86d2b28662b0de1d"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab1ba1d14dd3063cd86d2b28662b0de1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ab1ba1d14dd3063cd86d2b28662b0de1d">position</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ab1ba1d14dd3063cd86d2b28662b0de1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a position-finding pipe operation.  <br /></td></tr>
<tr class="separator:ab1ba1d14dd3063cd86d2b28662b0de1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65e96a2cd84dfff07e41cf04271aeaf" id="r_aa65e96a2cd84dfff07e41cf04271aeaf"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aa65e96a2cd84dfff07e41cf04271aeaf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#aa65e96a2cd84dfff07e41cf04271aeaf">find</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:aa65e96a2cd84dfff07e41cf04271aeaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an element-finding pipe operation.  <br /></td></tr>
<tr class="separator:aa65e96a2cd84dfff07e41cf04271aeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40db2ab3073964e2a307383b2d145012" id="r_a40db2ab3073964e2a307383b2d145012"><td class="memItemLeft" align="right" valign="top"><a id="a40db2ab3073964e2a307383b2d145012" name="a40db2ab3073964e2a307383b2d145012"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nanoseconds</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:a40db2ab3073964e2a307383b2d145012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776c1bca17ca146e7e4398d3e5843754" id="r_a776c1bca17ca146e7e4398d3e5843754"><td class="memItemLeft" align="right" valign="top"><a id="a776c1bca17ca146e7e4398d3e5843754" name="a776c1bca17ca146e7e4398d3e5843754"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>microseconds</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:a776c1bca17ca146e7e4398d3e5843754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae31e565c5bcfbf547db464bd9b72c1" id="r_abae31e565c5bcfbf547db464bd9b72c1"><td class="memItemLeft" align="right" valign="top"><a id="abae31e565c5bcfbf547db464bd9b72c1" name="abae31e565c5bcfbf547db464bd9b72c1"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>milliseconds</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:abae31e565c5bcfbf547db464bd9b72c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bf3ca2c6832cab545494a72669f343" id="r_a01bf3ca2c6832cab545494a72669f343"><td class="memItemLeft" align="right" valign="top"><a id="a01bf3ca2c6832cab545494a72669f343" name="a01bf3ca2c6832cab545494a72669f343"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>seconds</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:a01bf3ca2c6832cab545494a72669f343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1c540388170235a2f3671e41f631e3" id="r_a3d1c540388170235a2f3671e41f631e3"><td class="memItemLeft" align="right" valign="top"><a id="a3d1c540388170235a2f3671e41f631e3" name="a3d1c540388170235a2f3671e41f631e3"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>minutes</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:a3d1c540388170235a2f3671e41f631e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625e5e18c4a714e24d0f282d49bf54cd" id="r_a625e5e18c4a714e24d0f282d49bf54cd"><td class="memItemLeft" align="right" valign="top"><a id="a625e5e18c4a714e24d0f282d49bf54cd" name="a625e5e18c4a714e24d0f282d49bf54cd"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>hours</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:a625e5e18c4a714e24d0f282d49bf54cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d045524807616a996b8866cc108df0" id="r_af1d045524807616a996b8866cc108df0"><td class="memItemLeft" align="right" valign="top"><a id="af1d045524807616a996b8866cc108df0" name="af1d045524807616a996b8866cc108df0"></a>
<a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><b>days</b> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> val=1)</td></tr>
<tr class="separator:af1d045524807616a996b8866cc108df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71709e01e1763bb5d5d68c4ab2ea3cff" id="r_a71709e01e1763bb5d5d68c4ab2ea3cff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a71709e01e1763bb5d5d68c4ab2ea3cff">operator-</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:a71709e01e1763bb5d5d68c4ab2ea3cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571ffb224e3ea1ad91897a3af4d53b39" id="r_a571ffb224e3ea1ad91897a3af4d53b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a571ffb224e3ea1ad91897a3af4d53b39">operator+</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;lhs, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;rhs)</td></tr>
<tr class="separator:a571ffb224e3ea1ad91897a3af4d53b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3559df44608ee9e05533e59cf3057ed8" id="r_a3559df44608ee9e05533e59cf3057ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a3559df44608ee9e05533e59cf3057ed8">operator-</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;lhs, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;rhs)</td></tr>
<tr class="separator:a3559df44608ee9e05533e59cf3057ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d7a1e5da9c96bf3306758bd9df6a86" id="r_a34d7a1e5da9c96bf3306758bd9df6a86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a34d7a1e5da9c96bf3306758bd9df6a86">operator*</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d, <a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> factor)</td></tr>
<tr class="separator:a34d7a1e5da9c96bf3306758bd9df6a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8840232fdae1a0dfc11523b4c76ea5" id="r_a3b8840232fdae1a0dfc11523b4c76ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a3b8840232fdae1a0dfc11523b4c76ea5">operator*</a> (<a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> factor, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:a3b8840232fdae1a0dfc11523b4c76ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4304b0a4b1d5235efe7d7a294c38f90" id="r_ab4304b0a4b1d5235efe7d7a294c38f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ab4304b0a4b1d5235efe7d7a294c38f90">operator/</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d, <a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a> factor)</td></tr>
<tr class="separator:ab4304b0a4b1d5235efe7d7a294c38f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc5f294ceb9f35fa85d471c9949b24f" id="r_a8dc5f294ceb9f35fa85d471c9949b24f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a8dc5f294ceb9f35fa85d471c9949b24f">operator/</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;lhs, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;rhs)</td></tr>
<tr class="separator:a8dc5f294ceb9f35fa85d471c9949b24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7905f71eaf7dcdc5a815012507ca548" id="r_af7905f71eaf7dcdc5a815012507ca548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#af7905f71eaf7dcdc5a815012507ca548">abs</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:af7905f71eaf7dcdc5a815012507ca548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bb9f422bdfd6849f2005eb66aec97c" id="r_a22bb9f422bdfd6849f2005eb66aec97c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a22bb9f422bdfd6849f2005eb66aec97c">operator+</a> (const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;p, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:a22bb9f422bdfd6849f2005eb66aec97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada91297110e28b44f92d1e96b056c6d1" id="r_ada91297110e28b44f92d1e96b056c6d1"><td class="memItemLeft" align="right" valign="top"><a id="ada91297110e28b44f92d1e96b056c6d1" name="ada91297110e28b44f92d1e96b056c6d1"></a>
<a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d, const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;p)</td></tr>
<tr class="separator:ada91297110e28b44f92d1e96b056c6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c47bc54f331e0b0b66bde30d3e1147" id="r_a79c47bc54f331e0b0b66bde30d3e1147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a79c47bc54f331e0b0b66bde30d3e1147">operator-</a> (const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;p, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:a79c47bc54f331e0b0b66bde30d3e1147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7386518546690a3f8015c6c27a2acf79" id="r_a7386518546690a3f8015c6c27a2acf79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a7386518546690a3f8015c6c27a2acf79">operator-</a> (const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;lhs, const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;rhs)</td></tr>
<tr class="separator:a7386518546690a3f8015c6c27a2acf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1de45ff859295ba23c2d364183f529" id="r_a7c1de45ff859295ba23c2d364183f529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a7c1de45ff859295ba23c2d364183f529">operator+</a> (const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;t, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:a7c1de45ff859295ba23c2d364183f529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ccf365afdb7c6d38412641464f53c9" id="r_a24ccf365afdb7c6d38412641464f53c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a24ccf365afdb7c6d38412641464f53c9">operator+</a> (const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d, const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;t)</td></tr>
<tr class="separator:a24ccf365afdb7c6d38412641464f53c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c208f58e7680591e5f70aa566be36e3" id="r_a5c208f58e7680591e5f70aa566be36e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#a5c208f58e7680591e5f70aa566be36e3">operator-</a> (const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;t, const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;d)</td></tr>
<tr class="separator:a5c208f58e7680591e5f70aa566be36e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2744e60439a5d776543bd97d32627fa" id="r_ae2744e60439a5d776543bd97d32627fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ae2744e60439a5d776543bd97d32627fa">operator-</a> (const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;lhs, const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;rhs)</td></tr>
<tr class="separator:ae2744e60439a5d776543bd97d32627fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abd47f617dbcb368ac64505354d1a35fe" id="r_abd47f617dbcb368ac64505354d1a35fe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__TypeDefinitions.html#gab97e5374482de5baaded9620b95d5351">l_floating</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#abd47f617dbcb368ac64505354d1a35fe">E</a> = 2.7182818284590452353602874713526624977572470937000</td></tr>
<tr class="memdesc:abd47f617dbcb368ac64505354d1a35fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mathematical constant E (Euler's number).  <br /></td></tr>
<tr class="separator:abd47f617dbcb368ac64505354d1a35fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91dfcaba25870b33f8f72edcc791415" id="r_ab91dfcaba25870b33f8f72edcc791415"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__TypeDefinitions.html#gab97e5374482de5baaded9620b95d5351">l_floating</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoriginal.html#ab91dfcaba25870b33f8f72edcc791415">PI</a> = 3.1415926535897932384626433832795028841971693993751</td></tr>
<tr class="memdesc:ab91dfcaba25870b33f8f72edcc791415"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mathematical constant PI (π).  <br /></td></tr>
<tr class="separator:ab91dfcaba25870b33f8f72edcc791415"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the project Original. </p>
<p>The main namespace containing all core type system components.</p>
<p>Main namespace containing all hashing utilities.</p>
<p>This namespace serves as the main container for all modules and functionality within the Original project. It includes various classes, functions, and data structures that form the backbone of the system. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aaf4b8378a065c36e0724269370f084e7" name="aaf4b8378a065c36e0724269370f084e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4b8378a065c36e0724269370f084e7">&#9670;&#160;</a></span>makeReverseSequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceoriginal.html#aaf4b8378a065c36e0724269370f084e7">original::makeReverseSequence</a> = typedef decltype( <a class="el" href="namespaceoriginal.html#a4e51ab2bbc2425bdb4429bd3b2e87a14">reverseIndexSequenceImpl</a>(<a class="el" href="namespaceoriginal.html#a28819b16311a1c88f678fdec1055a719">makeSequence</a>&lt;N&gt;()) )</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a reversed index sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Length of the sequence to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classoriginal_1_1indexSequence.html" title="Compile-time sequence of unsigned integers.">indexSequence</a> instance with values N-1..0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af7905f71eaf7dcdc5a815012507ca548" name="af7905f71eaf7dcdc5a815012507ca548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7905f71eaf7dcdc5a815012507ca548">&#9670;&#160;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Duration to get absolute value of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute duration </dd></dl>

</div>
</div>
<a id="a303822f1cf65f29a40abc3883f0fb138" name="a303822f1cf65f29a40abc3883f0fb138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303822f1cf65f29a40abc3883f0fb138">&#9670;&#160;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::abs </td>
          <td>(</td>
          <td class="paramtype">TYPE&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the absolute value of a given number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of the input value.</dd></dl>
<p>This function returns the absolute value of the input argument <code>a</code>, which is the distance of <code>a</code> from zero. It works for both positive and negative values.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">int</span> a = -5;</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="namespaceoriginal.html#a303822f1cf65f29a40abc3883f0fb138">original::abs</a>(a); <span class="comment">// result will be 5</span></div>
<div class="ttc" id="anamespaceoriginal_html_a303822f1cf65f29a40abc3883f0fb138"><div class="ttname"><a href="namespaceoriginal.html#a303822f1cf65f29a40abc3883f0fb138">original::abs</a></div><div class="ttdeci">TYPE abs(TYPE a)</div><div class="ttdoc">Returns the absolute value of a given number.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2627c05d6a11986955cbd84456d08d90" name="a2627c05d6a11986955cbd84456d08d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2627c05d6a11986955cbd84456d08d90">&#9670;&#160;</a></span>all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all elements satisfy a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to check. </td></tr>
    <tr><td class="paramname">c</td><td>The validation predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all elements satisfy the predicate, false otherwise.</dd></dl>
<p>Short-circuits on first false result. Returns true for empty generators.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{2, 4, 6, 8};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keywordtype">bool</span> all_even = <a class="code hl_function" href="namespaceoriginal.html#a2627c05d6a11986955cbd84456d08d90">all</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });  <span class="comment">// Returns true</span></div>
<div class="ttc" id="aclassoriginal_1_1iterable_html_ae6819ade022d19dcbf5c06f046caa2dc"><div class="ttname"><a href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">original::iterable::generator</a></div><div class="ttdeci">coroutine::generator&lt; T &gt; generator() const</div><div class="ttdoc">Creates a coroutine generator that yields elements from this container.</div><div class="ttdef"><b>Definition</b> iterable.h:640</div></div>
<div class="ttc" id="aclassoriginal_1_1vector_html"><div class="ttname"><a href="classoriginal_1_1vector.html">original::vector</a></div><div class="ttdoc">Dynamic array container with amortized constant time operations.</div><div class="ttdef"><b>Definition</b> vector.h:43</div></div>
<div class="ttc" id="anamespaceoriginal_html_a2627c05d6a11986955cbd84456d08d90"><div class="ttname"><a href="namespaceoriginal.html#a2627c05d6a11986955cbd84456d08d90">original::all</a></div><div class="ttdeci">bool all(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c)</div><div class="ttdoc">Checks if all elements satisfy a predicate.</div><div class="ttdef"><b>Definition</b> generators.h:759</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a77a83f54429aae10a76283bdef427a44" name="a77a83f54429aae10a76283bdef427a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a83f54429aae10a76283bdef427a44">&#9670;&#160;</a></span>all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::all </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an all-match pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The validation predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that checks if all elements satisfy the predicate.</dd></dl>
<p>Factory function for creating all-match operations. </p>

</div>
</div>
<a id="aeb7fe159de2af67c79de5feffadad2a9" name="aeb7fe159de2af67c79de5feffadad2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7fe159de2af67c79de5feffadad2a9">&#9670;&#160;</a></span>any() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::any </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any element satisfies a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to check. </td></tr>
    <tr><td class="paramname">c</td><td>The existence predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if at least one element satisfies the predicate, false otherwise.</dd></dl>
<p>Short-circuits on first true result. Returns false for empty generators.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keywordtype">bool</span> has_even = <a class="code hl_function" href="namespaceoriginal.html#aeb7fe159de2af67c79de5feffadad2a9">any</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });  <span class="comment">// Returns true</span></div>
<div class="ttc" id="anamespaceoriginal_html_aeb7fe159de2af67c79de5feffadad2a9"><div class="ttname"><a href="namespaceoriginal.html#aeb7fe159de2af67c79de5feffadad2a9">original::any</a></div><div class="ttdeci">bool any(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c)</div><div class="ttdoc">Checks if any element satisfies a predicate.</div><div class="ttdef"><b>Definition</b> generators.h:781</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa756154f45cd9f39510c3c236167c39d" name="aa756154f45cd9f39510c3c236167c39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa756154f45cd9f39510c3c236167c39d">&#9670;&#160;</a></span>any() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::any </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an any-match pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The existence predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that checks if any element satisfies the predicate.</dd></dl>
<p>Factory function for creating any-match operations. </p>

</div>
</div>
<a id="ab9b1d89c1b09d143f3c13841db69bbb8" name="ab9b1d89c1b09d143f3c13841db69bbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b1d89c1b09d143f3c13841db69bbb8">&#9670;&#160;</a></span>collect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename SET  = hashSet&lt;TYPE&gt;&gt; <br />
requires ExtendsOf&lt;<a class="el" href="classoriginal_1_1set.html">set</a>&lt;TYPE, <a class="el" href="classoriginal_1_1allocator.html">allocator</a>&lt;<a class="el" href="classoriginal_1_1couple.html">couple</a>&lt;const TYPE, const bool&gt;&gt;&gt;, SET&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">SET original::collect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects generator elements into a set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of elements in the generator. </td></tr>
    <tr><td class="paramname">SET</td><td>The set type to collect into (default: <a class="el" href="classoriginal_1_1hashSet.html" title="Hash table based implementation of the set interface.">hashSet</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to collect from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set containing all unique elements from the generator.</dd></dl>
<p>Transforms a generator sequence into a set container, removing duplicates and providing fast lookup capabilities.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 2, 3, 3, 3};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> set = collect&lt;int&gt;(gen);  <span class="comment">// {1, 2, 3}</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae9e1ef4e30a4759f6609ea322a59e4c3" name="ae9e1ef4e30a4759f6609ea322a59e4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e1ef4e30a4759f6609ea322a59e4c3">&#9670;&#160;</a></span>count() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a count pipe operation. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that counts elements.</dd></dl>
<p>Factory function for creating count operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="a666b26e94abdc060e75dfbba14460615" name="a666b26e94abdc060e75dfbba14460615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666b26e94abdc060e75dfbba14460615">&#9670;&#160;</a></span>count() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> original::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts total elements in a generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the generator.</dd></dl>
<p>Consumes the generator and returns the total element count.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> cnt = <a class="code hl_function" href="namespaceoriginal.html#ae9e1ef4e30a4759f6609ea322a59e4c3">count</a>(gen);  <span class="comment">// Returns 5</span></div>
<div class="ttc" id="anamespaceoriginal_html_ae9e1ef4e30a4759f6609ea322a59e4c3"><div class="ttname"><a href="namespaceoriginal.html#ae9e1ef4e30a4759f6609ea322a59e4c3">original::count</a></div><div class="ttdeci">auto count()</div><div class="ttdoc">Creates a count pipe operation.</div><div class="ttdef"><b>Definition</b> generators.h:964</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa4508803490d4901c5a7ebb4db260586" name="aa4508803490d4901c5a7ebb4db260586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4508803490d4901c5a7ebb4db260586">&#9670;&#160;</a></span>count() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> original::count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts elements satisfying a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to count from. </td></tr>
    <tr><td class="paramname">c</td><td>The counting predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements satisfying the predicate.</dd></dl>
<p>Counts only elements for which the predicate returns true.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> even_count = <a class="code hl_function" href="namespaceoriginal.html#ae9e1ef4e30a4759f6609ea322a59e4c3">count</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });  <span class="comment">// Returns 2</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac6f71cd5625a315b1212e21ec8e399f0" name="ac6f71cd5625a315b1212e21ec8e399f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f71cd5625a315b1212e21ec8e399f0">&#9670;&#160;</a></span>count() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::count </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a conditional count pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The counting predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that counts elements satisfying the predicate.</dd></dl>
<p>Factory function for creating conditional count operations. </p>

</div>
</div>
<a id="a9420d79ec2ce055dbcee890a66d1b6cc" name="a9420d79ec2ce055dbcee890a66d1b6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9420d79ec2ce055dbcee890a66d1b6cc">&#9670;&#160;</a></span>enumerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::enumerate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an enumerate pipe operation. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that adds indices to elements.</dd></dl>
<p>Factory function for creating enumerate operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="a8c54968b94a7b8bd4f4b1737928ba785" name="a8c54968b94a7b8bd4f4b1737928ba785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c54968b94a7b8bd4f4b1737928ba785">&#9670;&#160;</a></span>enumerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; <a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>, TYPE &gt; &gt; original::enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates elements of a generator with their indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of elements in the generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to enumerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding couples of index and element.</dd></dl>
<p>Creates a sequence of (index, value) pairs starting from index 0. Useful for tracking element positions during iteration.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{10, 20, 30};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> [i, val] : <a class="code hl_function" href="namespaceoriginal.html#a9420d79ec2ce055dbcee890a66d1b6cc">enumerate</a>(gen)) {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;  <span class="comment">// 0: 10, 1: 20, 2: 30</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceoriginal_html_a9420d79ec2ce055dbcee890a66d1b6cc"><div class="ttname"><a href="namespaceoriginal.html#a9420d79ec2ce055dbcee890a66d1b6cc">original::enumerate</a></div><div class="ttdeci">auto enumerate()</div><div class="ttdoc">Creates an enumerate pipe operation.</div><div class="ttdef"><b>Definition</b> generators.h:916</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a412484dedc20d4058afc716f9da12ef0" name="a412484dedc20d4058afc716f9da12ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412484dedc20d4058afc716f9da12ef0">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; original::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts elements that do not satisfy a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The source generator. </td></tr>
    <tr><td class="paramname">c</td><td>The exclusion predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding elements that do not satisfy the predicate.</dd></dl>
<p>Opposite of <a class="el" href="namespaceoriginal.html#a3bb963df451f2091ae65a71e792c96a5" title="Filters generator elements based on a predicate.">filters()</a> - excludes elements that match the predicate and includes all others.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> not_evens = <a class="code hl_function" href="namespaceoriginal.html#a412484dedc20d4058afc716f9da12ef0">extract</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });</div>
<div class="line"><span class="comment">// Yields: 1, 3, 5</span></div>
<div class="ttc" id="anamespaceoriginal_html_a412484dedc20d4058afc716f9da12ef0"><div class="ttname"><a href="namespaceoriginal.html#a412484dedc20d4058afc716f9da12ef0">original::extract</a></div><div class="ttdeci">coroutine::generator&lt; TYPE &gt; extract(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c)</div><div class="ttdoc">Extracts elements that do not satisfy a predicate.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5ed9f8b310e05aeaca3de7372dbfed0a" name="a5ed9f8b310e05aeaca3de7372dbfed0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed9f8b310e05aeaca3de7372dbfed0a">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::extract </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an extract pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The exclusion predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that applies the extraction.</dd></dl>
<p>Factory function for creating extract operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="a3bb963df451f2091ae65a71e792c96a5" name="a3bb963df451f2091ae65a71e792c96a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb963df451f2091ae65a71e792c96a5">&#9670;&#160;</a></span>filters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; original::filters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters generator elements based on a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The source generator. </td></tr>
    <tr><td class="paramname">c</td><td>The filter predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding only elements that satisfy the predicate.</dd></dl>
<p>Creates a new generator that only includes elements for which the predicate returns true.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> evens = <a class="code hl_function" href="namespaceoriginal.html#a3bb963df451f2091ae65a71e792c96a5">filters</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });</div>
<div class="line"><span class="comment">// Yields: 2, 4</span></div>
<div class="ttc" id="anamespaceoriginal_html_a3bb963df451f2091ae65a71e792c96a5"><div class="ttname"><a href="namespaceoriginal.html#a3bb963df451f2091ae65a71e792c96a5">original::filters</a></div><div class="ttdeci">coroutine::generator&lt; TYPE &gt; filters(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c)</div><div class="ttdoc">Filters generator elements based on a predicate.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad1d773c3caafcbede851abef6b93ff8c" name="ad1d773c3caafcbede851abef6b93ff8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d773c3caafcbede851abef6b93ff8c">&#9670;&#160;</a></span>filters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::filters </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a filter pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The filter predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that applies the filter.</dd></dl>
<p>Factory function for creating filter operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="a2fe065ee79ac890811d903963ec10724" name="a2fe065ee79ac890811d903963ec10724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe065ee79ac890811d903963ec10724">&#9670;&#160;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first element satisfying a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to search. </td></tr>
    <tr><td class="paramname">c</td><td>The search predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first matching element, or default-constructed <code>TYPE</code> if not found.</dd></dl>
<p>Returns the first element that satisfies the predicate. If no element matches, returns a default-constructed value of type <code>TYPE</code>.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{10, 20, 30, 40};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> found = <a class="code hl_function" href="namespaceoriginal.html#a2fe065ee79ac890811d903963ec10724">find</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x &gt; 25; });  <span class="comment">// Returns 30</span></div>
<div class="ttc" id="anamespaceoriginal_html_a2fe065ee79ac890811d903963ec10724"><div class="ttname"><a href="namespaceoriginal.html#a2fe065ee79ac890811d903963ec10724">original::find</a></div><div class="ttdeci">TYPE find(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c)</div><div class="ttdoc">Finds the first element satisfying a predicate.</div><div class="ttdef"><b>Definition</b> generators.h:863</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa65e96a2cd84dfff07e41cf04271aeaf" name="aa65e96a2cd84dfff07e41cf04271aeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65e96a2cd84dfff07e41cf04271aeaf">&#9670;&#160;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::find </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an element-finding pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The search predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that finds the first matching element.</dd></dl>
<p>Factory function for creating element-finding operations. </p>

</div>
</div>
<a id="aebdceaa66d583b7fc47948a98e3d2478" name="aebdceaa66d583b7fc47948a98e3d2478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdceaa66d583b7fc47948a98e3d2478">&#9670;&#160;</a></span>flatten() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::flatten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a flatten pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The first element type in couples. </td></tr>
    <tr><td class="paramname">U</td><td>The second element type in couples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that flattens couples.</dd></dl>
<p>Factory function for creating flatten operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="a9a9970494c43ee8edd531daa3b67b4eb" name="a9a9970494c43ee8edd531daa3b67b4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9970494c43ee8edd531daa3b67b4eb">&#9670;&#160;</a></span>flatten() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::convertible_to&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt; original::flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; T, U &gt; &gt;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens a generator of couples into a single generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of first element in couples. </td></tr>
    <tr><td class="paramname">U</td><td>Type of second element in couples (must be convertible to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>Generator of couples. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding all elements from the couples sequentially.</dd></dl>
<p>Converts a generator of pairs into a flat sequence by yielding both elements of each couple in order.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{<a class="code hl_class" href="classoriginal_1_1couple.html">couple</a>{1, 2}, couple{3, 4}};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.generator();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> val : <a class="code hl_function" href="namespaceoriginal.html#aebdceaa66d583b7fc47948a98e3d2478">flatten</a>(gen)) {</div>
<div class="line">    <span class="comment">// Yields: 1, 2, 3, 4</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassoriginal_1_1couple_html"><div class="ttname"><a href="classoriginal_1_1couple.html">original::couple</a></div><div class="ttdoc">Container for two heterogeneous elements.</div><div class="ttdef"><b>Definition</b> couple.h:37</div></div>
<div class="ttc" id="anamespaceoriginal_html_aebdceaa66d583b7fc47948a98e3d2478"><div class="ttname"><a href="namespaceoriginal.html#aebdceaa66d583b7fc47948a98e3d2478">original::flatten</a></div><div class="ttdeci">auto flatten()</div><div class="ttdoc">Creates a flatten pipe operation.</div><div class="ttdef"><b>Definition</b> generators.h:948</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abcc95f4b01319d7d40643c55df213e3d" name="abcc95f4b01319d7d40643c55df213e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc95f4b01319d7d40643c55df213e3d">&#9670;&#160;</a></span>group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from single filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter to group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a></dd></dl>
<p>Enables future operator precedence modifications </p>

</div>
</div>
<a id="acd6ae231e8e4a92af1e9f3940f249c70" name="acd6ae231e8e4a92af1e9f3940f249c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6ae231e8e4a92af1e9f3940f249c70">&#9670;&#160;</a></span>group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> to group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New grouped <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a></dd></dl>
<p>Use instead of parentheses for explicit precedence control </p>

</div>
</div>
<a id="a318cbbdd897afa6e01dd427c9ed8b2b1" name="a318cbbdd897afa6e01dd427c9ed8b2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318cbbdd897afa6e01dd427c9ed8b2b1">&#9670;&#160;</a></span>join() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::convertible_to&lt; T &gt; U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt; original::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>gen1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>gen2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins two generators of compatible types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of first generator and result elements. </td></tr>
    <tr><td class="paramname">U</td><td>Type of second generator elements (must be convertible to T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen1</td><td>First generator. </td></tr>
    <tr><td class="paramname">gen2</td><td>Second generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding all elements from gen1 followed by gen2.</dd></dl>
<p>Concatenates two generators, converting elements from the second generator to the type of the first.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec1 = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> vec2 = vector{4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen1 = vec1.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> gen2 = vec2.generator();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> val : <a class="code hl_function" href="namespaceoriginal.html#a318cbbdd897afa6e01dd427c9ed8b2b1">join</a>(gen1, gen2)) {</div>
<div class="line">    <span class="comment">// Yields: 1, 2, 3, 4, 5</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceoriginal_html_a318cbbdd897afa6e01dd427c9ed8b2b1"><div class="ttname"><a href="namespaceoriginal.html#a318cbbdd897afa6e01dd427c9ed8b2b1">original::join</a></div><div class="ttdeci">coroutine::generator&lt; T &gt; join(coroutine::generator&lt; T &gt; gen1, coroutine::generator&lt; U &gt; gen2)</div><div class="ttdoc">Joins two generators of compatible types.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abc6b7b3c430ab35988b6ab12d107e0bd" name="abc6b7b3c430ab35988b6ab12d107e0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6b7b3c430ab35988b6ab12d107e0bd">&#9670;&#160;</a></span>join() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>gen2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a join pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target element type. </td></tr>
    <tr><td class="paramname">U</td><td>The source element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen2</td><td>The generator to join with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that joins generators.</dd></dl>
<p>Factory function for creating join operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="aeec02bedf05dad00be37632abf5d63f3" name="aeec02bedf05dad00be37632abf5d63f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec02bedf05dad00be37632abf5d63f3">&#9670;&#160;</a></span>list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , template&lt; typename &gt; typename SERIAL = vector&gt; <br />
requires ExtendsOf&lt;<a class="el" href="classoriginal_1_1baseList.html">baseList</a>&lt;TYPE, <a class="el" href="classoriginal_1_1allocator.html">allocator</a>&lt;TYPE&gt;&gt;, SERIAL&lt;TYPE&gt;&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">SERIAL&lt; TYPE &gt; original::list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects generator elements into a list container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of elements in the generator. </td></tr>
    <tr><td class="paramname">SERIAL</td><td>The list container type (default: vector). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to collect from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list container with all generator elements in order.</dd></dl>
<p>Converts a generator sequence into a concrete list container, preserving element order and allowing random access.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> gen = someContainer.generator();</div>
<div class="line"><span class="keyword">auto</span> vec = list&lt;int&gt;(gen);  <span class="comment">// Creates vector&lt;int&gt; with all elements</span></div>
</div><!-- fragment --> <dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2original_2original_2src_2core_2vector_8h-example.html#a8">/home/runner/work/original/original/src/core/vector.h</a>.</dd>
</dl>

</div>
</div>
<a id="a5bebb9ab61ff7783b0fb2c90704246a1" name="a5bebb9ab61ff7783b0fb2c90704246a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bebb9ab61ff7783b0fb2c90704246a1">&#9670;&#160;</a></span>makeOwnerPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DEL  = deleter&lt;T&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt; original::makeOwnerPtr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to create and manage </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: deleter&lt;T&gt;) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for object construction </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ownerPtr&lt;T, DEL&gt; owning the newly created object </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe object creation </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> has exclusive ownership of the object</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create an ownerPtr managing a new MyClass constructed with args</span></div>
<div class="line"><span class="keyword">auto</span> ptr = makeOwnerPtr&lt;MyClass&gt;(arg1, arg2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a84c2ad6f571fb457b96abd1ab2dd660f" name="a84c2ad6f571fb457b96abd1ab2dd660f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c2ad6f571fb457b96abd1ab2dd660f">&#9670;&#160;</a></span>makeOwnerPtrArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DEL  = deleter&lt;T[]&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1ownerPtr.html">ownerPtr</a>&lt; T, DEL &gt; original::makeOwnerPtrArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> managing a dynamically allocated array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of array elements to create </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: deleter&lt;T[]&gt;) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for array element initialization </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of elements in the array </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to each element's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ownerPtr&lt;T, DEL&gt; owning the newly created array </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe array creation </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned <a class="el" href="classoriginal_1_1ownerPtr.html" title="Unique ownership smart pointer with move semantics.">ownerPtr</a> has exclusive ownership of the array</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Create an ownerPtr managing a new MyClass[10] array</span></div>
<div class="line"><span class="keyword">auto</span> arr = makeOwnerPtrArray&lt;MyClass&gt;(10);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a28819b16311a1c88f678fdec1055a719" name="a28819b16311a1c88f678fdec1055a719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28819b16311a1c88f678fdec1055a719">&#9670;&#160;</a></span>makeSequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> NUM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">consteval auto original::makeSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an index sequence of given length. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NUM</td><td>Length of the sequence to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classoriginal_1_1indexSequence.html" title="Compile-time sequence of unsigned integers.">indexSequence</a> instance with values 0..NUM-1 </dd></dl>

</div>
</div>
<a id="ab3a918750a407487641ef6924df40d8d" name="ab3a918750a407487641ef6924df40d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a918750a407487641ef6924df40d8d">&#9670;&#160;</a></span>makeStrongPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DEL  = deleter&lt;T&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt; original::makeStrongPtr </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to create and manage </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: deleter&lt;T&gt;) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for object construction </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to T's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>strongPtr&lt;T, DEL&gt; sharing ownership of the new object </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe object creation with shared ownership</dd></dl>
<p>The object will be destroyed when all strong references are released</p>
<div class="fragment"><div class="line"><span class="comment">// Create a strongPtr managing a new MyClass constructed with args</span></div>
<div class="line"><span class="keyword">auto</span> ptr = makeStrongPtr&lt;MyClass&gt;(arg1, arg2);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a70101a33a2bf1305a42a180652c98c95" name="a70101a33a2bf1305a42a180652c98c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70101a33a2bf1305a42a180652c98c95">&#9670;&#160;</a></span>makeStrongPtrArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DEL  = deleter&lt;T[]&gt;, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1strongPtr.html">strongPtr</a>&lt; T, DEL &gt; original::makeStrongPtrArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classoriginal_1_1strongPtr.html" title="Shared ownership smart pointer with strong references.">strongPtr</a> managing a shared array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of array elements to create </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type (default: deleter&lt;T[]&gt;) </td></tr>
    <tr><td class="paramname">Args</td><td>Argument types for array element initialization </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of elements in the array </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to forward to each element's constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>strongPtr&lt;T, DEL&gt; sharing ownership of the new array </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Provides exception-safe array creation with shared ownership</dd></dl>
<p>The array will be destroyed when all strong references are released</p>
<div class="fragment"><div class="line"><span class="comment">// Create a strongPtr managing a new MyClass[10] array</span></div>
<div class="line"><span class="keyword">auto</span> arr = makeStrongPtrArray&lt;MyClass&gt;(10);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0f42f26b6aa61acc458a6bfd9c49581f" name="a0f42f26b6aa61acc458a6bfd9c49581f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f42f26b6aa61acc458a6bfd9c49581f">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::max </td>
          <td>(</td>
          <td class="paramtype">TYPE&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the larger of two given values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the input values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first input value. </td></tr>
    <tr><td class="paramname">b</td><td>The second input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The larger of <code>a</code> and <code>b</code>.</dd></dl>
<p>This function compares the two values <code>a</code> and <code>b</code>, and returns the value that is greater.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">double</span> a = 3.5, b = 7.2;</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="namespaceoriginal.html#a0f42f26b6aa61acc458a6bfd9c49581f">original::max</a>(a, b); <span class="comment">// result will be 7.2</span></div>
<div class="ttc" id="anamespaceoriginal_html_a0f42f26b6aa61acc458a6bfd9c49581f"><div class="ttname"><a href="namespaceoriginal.html#a0f42f26b6aa61acc458a6bfd9c49581f">original::max</a></div><div class="ttdeci">TYPE max(TYPE a, TYPE b)</div><div class="ttdoc">Returns the larger of two given values.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0d69e120da2a56a2e72fc9834edfb0ec" name="a0d69e120da2a56a2e72fc9834edfb0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d69e120da2a56a2e72fc9834edfb0ec">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TYPE original::min </td>
          <td>(</td>
          <td class="paramtype">TYPE&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TYPE&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the smaller of two given values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The type of the input values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first input value. </td></tr>
    <tr><td class="paramname">b</td><td>The second input value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The smaller of <code>a</code> and <code>b</code>.</dd></dl>
<p>This function compares the two values <code>a</code> and <code>b</code>, and returns the value that is smaller.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">double</span> a = 3.5, b = 7.2;</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="namespaceoriginal.html#a0d69e120da2a56a2e72fc9834edfb0ec">original::min</a>(a, b); <span class="comment">// result will be 3.5</span></div>
<div class="ttc" id="anamespaceoriginal_html_a0d69e120da2a56a2e72fc9834edfb0ec"><div class="ttname"><a href="namespaceoriginal.html#a0d69e120da2a56a2e72fc9834edfb0ec">original::min</a></div><div class="ttdeci">TYPE min(TYPE a, TYPE b)</div><div class="ttdoc">Returns the smaller of two given values.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae0132dd122c3a7025a465c7b8aacf9a3" name="ae0132dd122c3a7025a465c7b8aacf9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0132dd122c3a7025a465c7b8aacf9a3">&#9670;&#160;</a></span>none() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classoriginal_1_1none.html">original::none</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if no elements satisfy a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to check. </td></tr>
    <tr><td class="paramname">c</td><td>The exclusion predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if no elements satisfy the predicate, false otherwise.</dd></dl>
<p>Short-circuits on first true result. Returns true for empty generators.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 3, 5, 7};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keywordtype">bool</span> no_evens = none(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });  <span class="comment">// Returns true</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a354ee852b16ecb9f5275b54a2b178c65" name="a354ee852b16ecb9f5275b54a2b178c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354ee852b16ecb9f5275b54a2b178c65">&#9670;&#160;</a></span>none() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classoriginal_1_1none.html">original::none</a> </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a none-match pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The exclusion predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that checks if no elements satisfy the predicate.</dd></dl>
<p>Factory function for creating none-match operations. </p>

</div>
</div>
<a id="a1fb35d1af29a0c0be3a17081b9ca9dd0" name="a1fb35d1af29a0c0be3a17081b9ca9dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb35d1af29a0c0be3a17081b9ca9dd0">&#9670;&#160;</a></span>operator!() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> with NOT operation </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically adds grouping parentheses </dd></dl>

</div>
</div>
<a id="ad74fe2f9ca0a3e0a5dc33272f50e56e8" name="ad74fe2f9ca0a3e0a5dc33272f50e56e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74fe2f9ca0a3e0a5dc33272f50e56e8">&#9670;&#160;</a></span>operator!() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator! </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from existing stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New negated <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Automatically adds grouping parentheses </dd></dl>

</div>
</div>
<a id="a6abd88507c603855fa51d10a83c73dbb" name="a6abd88507c603855fa51d10a83c73dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abd88507c603855fa51d10a83c73dbb">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DER , typename DEL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoriginal.html#a1fb35d1af29a0c0be3a17081b9ca9dd0">original::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison with nullptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is not empty (has a managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking operator bool() of ptr </dd></dl>

</div>
</div>
<a id="a1d01647f32db1756ca882182fd605d88" name="a1d01647f32db1756ca882182fd605d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d01647f32db1756ca882182fd605d88">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoriginal.html#a1fb35d1af29a0c0be3a17081b9ca9dd0">original::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison operator for iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements the iterator traverses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_it</td><td>Left-hand side iterator. </td></tr>
    <tr><td class="paramname">r_it</td><td>Right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators point to different elements, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation uses <code>equalPtr</code> for optimal constant-time comparison. </dd></dl>

</div>
</div>
<a id="a2667642f0077e1d94fbeaafcd8cf376f" name="a2667642f0077e1d94fbeaafcd8cf376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2667642f0077e1d94fbeaafcd8cf376f">&#9670;&#160;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DER , typename DEL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceoriginal.html#a1fb35d1af29a0c0be3a17081b9ca9dd0">original::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inequality comparison with nullptr (reversed operands) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is not empty (has a managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking operator bool() of ptr </dd></dl>

</div>
</div>
<a id="aab2fc6dcf8fe5e54dd7bafdb775e2398" name="aab2fc6dcf8fe5e54dd7bafdb775e2398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2fc6dcf8fe5e54dd7bafdb775e2398">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbs</td><td>The left <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
    <tr><td class="paramname">rbs</td><td>The right <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the AND operation. </dd></dl>

</div>
</div>
<a id="a1f9161566f8b79c18b9f7d44716e71ae" name="a1f9161566f8b79c18b9f7d44716e71ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9161566f8b79c18b9f7d44716e71ae">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AND operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a1db8c31a0d9119ae22cc0ee854023eb4" name="a1db8c31a0d9119ae22cc0ee854023eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db8c31a0d9119ae22cc0ee854023eb4">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create AND <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>First filter operand </td></tr>
    <tr><td class="paramname">f2</td><td>Second filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> with AND operation </dd></dl>

</div>
</div>
<a id="a32c593192f7fe4c1d14e221fe9407369" name="a32c593192f7fe4c1d14e221fe9407369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c593192f7fe4c1d14e221fe9407369">&#9670;&#160;</a></span>operator&amp;&amp;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AND operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a34d7a1e5da9c96bf3306758bd9df6a86" name="a34d7a1e5da9c96bf3306758bd9df6a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d7a1e5da9c96bf3306758bd9df6a86">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Duration to multiply </td></tr>
    <tr><td class="paramname">factor</td><td>Multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of duration and factor </dd></dl>

</div>
</div>
<a id="a3b8840232fdae1a0dfc11523b4c76ea5" name="a3b8840232fdae1a0dfc11523b4c76ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8840232fdae1a0dfc11523b4c76ea5">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Multiplication factor </td></tr>
    <tr><td class="paramname">d</td><td>Duration to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of factor and duration </dd></dl>

</div>
</div>
<a id="a176d8ed479959a50d637c2ee6900a159" name="a176d8ed479959a50d637c2ee6900a159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176d8ed479959a50d637c2ee6900a159">&#9670;&#160;</a></span>operator+() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a>&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a number of steps to the iterator's current position and returns a new iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements the iterator will traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to move. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to move forward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that is moved forward by the specified steps from the original iterator.</dd></dl>
<p>This operator does not modify the original iterator, but creates a new one that is advanced by <code>steps</code> positions. </p>

</div>
</div>
<a id="a24ccf365afdb7c6d38412641464f53c9" name="a24ccf365afdb7c6d38412641464f53c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ccf365afdb7c6d38412641464f53c9">&#9670;&#160;</a></span>operator+() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1UTCTime.html">original::time::UTCTime</a> original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Duration to add </td></tr>
    <tr><td class="paramname">t</td><td>UTCTime </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New UTCTime after addition </dd></dl>

</div>
</div>
<a id="a571ffb224e3ea1ad91897a3af4d53b39" name="a571ffb224e3ea1ad91897a3af4d53b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571ffb224e3ea1ad91897a3af4d53b39">&#9670;&#160;</a></span>operator+() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of durations </dd></dl>

</div>
</div>
<a id="a22bb9f422bdfd6849f2005eb66aec97c" name="a22bb9f422bdfd6849f2005eb66aec97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bb9f422bdfd6849f2005eb66aec97c">&#9670;&#160;</a></span>operator+() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1point.html">original::time::point</a> original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Time point </td></tr>
    <tr><td class="paramname">d</td><td>Duration to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New time point after addition </dd></dl>

</div>
</div>
<a id="a7c1de45ff859295ba23c2d364183f529" name="a7c1de45ff859295ba23c2d364183f529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1de45ff859295ba23c2d364183f529">&#9670;&#160;</a></span>operator+() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1UTCTime.html">original::time::UTCTime</a> original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>UTCTime </td></tr>
    <tr><td class="paramname">d</td><td>Duration to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New UTCTime after addition </dd></dl>

</div>
</div>
<a id="ae47ef543dcb851270ddb7b59ae4ae103" name="ae47ef543dcb851270ddb7b59ae4ae103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47ef543dcb851270ddb7b59ae4ae103">&#9670;&#160;</a></span>operator+() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new stream by prefixing existing stream. </p>
<p>Creates new stream from transformation and existing stream.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Transformation to prepend </td></tr>
    <tr><td class="paramname">ots</td><td>Original stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New stream applying t then ots's transformations </dd></dl>

</div>
</div>
<a id="a38a26f512ed3d73721da23b1f19437f6" name="a38a26f512ed3d73721da23b1f19437f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a26f512ed3d73721da23b1f19437f6">&#9670;&#160;</a></span>operator+() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1transformStream.html">transformStream</a>&lt; T &gt; original::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1transform.html">transform</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new transformation stream from two transforms. </p>
<p>Creates new stream from two transformations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>First transformation </td></tr>
    <tr><td class="paramname">t2</td><td>Second transformation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New stream applying t1 then t2 </dd></dl>

</div>
</div>
<a id="a2e78d5e4c7f280f178b3812298ef44b3" name="a2e78d5e4c7f280f178b3812298ef44b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e78d5e4c7f280f178b3812298ef44b3">&#9670;&#160;</a></span>operator-() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a>&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts a number of steps from the iterator's current position and returns a new iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the elements the iterator will traverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator to move. </td></tr>
    <tr><td class="paramname">steps</td><td>The number of steps to move backward. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new iterator that is moved backward by the specified steps from the original iterator.</dd></dl>
<p>This operator does not modify the original iterator, but creates a new one that is moved backward by <code>steps</code> positions. </p>

</div>
</div>
<a id="a71709e01e1763bb5d5d68c4ab2ea3cff" name="a71709e01e1763bb5d5d68c4ab2ea3cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71709e01e1763bb5d5d68c4ab2ea3cff">&#9670;&#160;</a></span>operator-() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Duration to negate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negated duration </dd></dl>

</div>
</div>
<a id="a3559df44608ee9e05533e59cf3057ed8" name="a3559df44608ee9e05533e59cf3057ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3559df44608ee9e05533e59cf3057ed8">&#9670;&#160;</a></span>operator-() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Difference of durations </dd></dl>

</div>
</div>
<a id="a7386518546690a3f8015c6c27a2acf79" name="a7386518546690a3f8015c6c27a2acf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7386518546690a3f8015c6c27a2acf79">&#9670;&#160;</a></span>operator-() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Duration between points </dd></dl>

</div>
</div>
<a id="a79c47bc54f331e0b0b66bde30d3e1147" name="a79c47bc54f331e0b0b66bde30d3e1147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c47bc54f331e0b0b66bde30d3e1147">&#9670;&#160;</a></span>operator-() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1point.html">original::time::point</a> original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1point.html">time::point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Time point </td></tr>
    <tr><td class="paramname">d</td><td>Duration to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New time point after subtraction </dd></dl>

</div>
</div>
<a id="ae2744e60439a5d776543bd97d32627fa" name="ae2744e60439a5d776543bd97d32627fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2744e60439a5d776543bd97d32627fa">&#9670;&#160;</a></span>operator-() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Duration between UTCTimes </dd></dl>

</div>
</div>
<a id="a5c208f58e7680591e5f70aa566be36e3" name="a5c208f58e7680591e5f70aa566be36e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c208f58e7680591e5f70aa566be36e3">&#9670;&#160;</a></span>operator-() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1UTCTime.html">original::time::UTCTime</a> original::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1UTCTime.html">time::UTCTime</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>UTCTime </td></tr>
    <tr><td class="paramname">d</td><td>Duration to subtract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New UTCTime after subtraction </dd></dl>

</div>
</div>
<a id="ab4304b0a4b1d5235efe7d7a294c38f90" name="ab4304b0a4b1d5235efe7d7a294c38f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4304b0a4b1d5235efe7d7a294c38f90">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1time.html#ac876058544747caee0f24703ab252636">time::time_val_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>Duration to divide </td></tr>
    <tr><td class="paramname">factor</td><td>Division factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Quotient of duration and factor </dd></dl>

</div>
</div>
<a id="a8dc5f294ceb9f35fa85d471c9949b24f" name="a8dc5f294ceb9f35fa85d471c9949b24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc5f294ceb9f35fa85d471c9949b24f">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1time_1_1duration.html">original::time::duration</a> original::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1time_1_1duration.html">time::duration</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>Right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Quotient of durations </dd></dl>

</div>
</div>
<a id="a6bf3733f8dbb6afdb7c4b4559c262da4" name="a6bf3733f8dbb6afdb7c4b4559c262da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf3733f8dbb6afdb7c4b4559c262da4">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; original::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1printable.html">printable</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stream insertion operator for printable objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">p</td><td>Printable object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Modified output stream</dd></dl>
<div class="fragment"><div class="line">MyClass obj;</div>
<div class="line">std::cout &lt;&lt; obj; <span class="comment">// Outputs &quot;printable(@0x7ffd)&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8dc21f8c884d90b6204bcd6890033aa6" name="a8dc21f8c884d90b6204bcd6890033aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc21f8c884d90b6204bcd6890033aa6">&#9670;&#160;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DER , typename DEL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison with nullptr. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is empty (no managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking !operator bool() of ptr </dd></dl>

</div>
</div>
<a id="aebe93d9c1453d7be3fa90077fd1b8f03" name="aebe93d9c1453d7be3fa90077fd1b8f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe93d9c1453d7be3fa90077fd1b8f03">&#9670;&#160;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1iterator.html">iterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison operator for iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements the iterator traverses. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_it</td><td>Left-hand side iterator. </td></tr>
    <tr><td class="paramname">r_it</td><td>Right-hand side iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the iterators point to the same element, false otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This operation uses <code>equalPtr</code> for optimal constant-time comparison. </dd></dl>

</div>
</div>
<a id="ae58f360a00f6b41e2f064a4b6c0c6421" name="ae58f360a00f6b41e2f064a4b6c0c6421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58f360a00f6b41e2f064a4b6c0c6421">&#9670;&#160;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DER , typename DEL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool original::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::nullptr_t &amp;&#160;</td>
          <td class="paramname"><em>null</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1autoPtr.html">autoPtr</a>&lt; T, DER, DEL &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison with nullptr (reversed operands) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Managed object type </td></tr>
    <tr><td class="paramname">DER</td><td>CRTP derived class type </td></tr>
    <tr><td class="paramname">DEL</td><td>Deleter policy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td><a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> to compare </td></tr>
    <tr><td class="paramname">null</td><td>nullptr_t to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classoriginal_1_1autoPtr.html" title="Base smart pointer with reference counting.">autoPtr</a> is empty (no managed object) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Equivalent to checking !operator bool() of ptr </dd></dl>

</div>
</div>
<a id="a696ec502e77d87595609396f9bae2a62" name="a696ec502e77d87595609396f9bae2a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ec502e77d87595609396f9bae2a62">&#9670;&#160;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbs</td><td>The left <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
    <tr><td class="paramname">rbs</td><td>The right <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the XOR operation. </dd></dl>

</div>
</div>
<a id="aeba3c2d7cc56cc45d532cca8f22dd2c1" name="aeba3c2d7cc56cc45d532cca8f22dd2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeba3c2d7cc56cc45d532cca8f22dd2c1">&#9670;&#160;</a></span>operator|() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1async_1_1future.html">async::future</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe operator for chaining asynchronous computations. </p>
<p>This operator dynamically attaches a new callback to an already running future. The callback will be executed once the asynchronous result becomes available. Unlike a lazy pipeline builder, this version modifies the execution flow immediately.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Result type of the future </td></tr>
    <tr><td class="paramname">Callback</td><td>Callable type, must accept T or T&amp;&amp; (depending on constness and value category) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Source future containing the asynchronous result </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to process the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new future holding the result of the callback </dd></dl>

</div>
</div>
<a id="ae72f04021dc08546003a51eae52bc8a7" name="ae72f04021dc08546003a51eae52bc8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72f04021dc08546003a51eae52bc8a7">&#9670;&#160;</a></span>operator|() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1async_1_1future.html">async::future</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe operator specialization for future&lt;void&gt; </p>
<p>This operator dynamically attaches a new callback to an already running future&lt;void&gt;. The callback will be executed once the asynchronous task completes. This is suitable for chaining tasks that do not produce a value. Execution is immediate, not deferred.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Callback</td><td>Callable type, must accept no arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Source future&lt;void&gt; representing completion of an asynchronous task </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to execute after completion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new future holding the result of the callback </dd></dl>

</div>
</div>
<a id="a55282b584ea2c4a589d358e60e98efe5" name="a55282b584ea2c4a589d358e60e98efe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55282b584ea2c4a589d358e60e98efe5">&#9670;&#160;</a></span>operator|() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callback1 , typename Callback2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1async_1_1promise.html">async::promise</a>&lt; T, Callback1 &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazy pipe operator for chaining promise computations. </p>
<p>This operator creates a lazy composition of promises, where the computation is only executed when the resulting promise is run. Unlike the dynamic pipe operator for futures, this creates a new promise that combines both computations without immediate execution.</p>
<p>The pipeline is built lazily - no computation occurs until run() is called on the resulting promise. This allows for building complex computation graphs without immediate execution overhead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Result type of the source promise </td></tr>
    <tr><td class="paramname">Callback1</td><td>Type of the source promise's computation </td></tr>
    <tr><td class="paramname">Callback2</td><td>Type of the continuation callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Source promise containing the initial computation </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to process the result of the source promise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new promise that will execute both computations in sequence when run </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The source promise is moved into the resulting promise, making it invalid after this operation. The continuation callback must accept the result type T. </dd></dl>

</div>
</div>
<a id="a4e54e02f38ce013d7568d2353cfc0fff" name="a4e54e02f38ce013d7568d2353cfc0fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e54e02f38ce013d7568d2353cfc0fff">&#9670;&#160;</a></span>operator|() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callback1 , typename Callback2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1async_1_1promise.html">async::promise</a>&lt; void, Callback1 &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lazy pipe operator specialization for promise&lt;void&gt; </p>
<p>This operator creates a lazy composition of void-returning promises, where the first computation completes before the second begins. The pipeline executes sequentially but only when the resulting promise is run.</p>
<p>Useful for building sequences of side-effectful operations that need to execute in order but don't produce values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Callback1</td><td>Type of the source promise's computation </td></tr>
    <tr><td class="paramname">Callback2</td><td>Type of the continuation callback </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Source promise containing the initial void computation </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to execute after the source promise completes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new promise that will execute both computations in sequence when run </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The source promise is moved into the resulting promise, making it invalid after this operation. The continuation callback must accept no arguments. </dd></dl>

</div>
</div>
<a id="a331c010dbb900d7462ab212169ff78e0" name="a331c010dbb900d7462ab212169ff78e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c010dbb900d7462ab212169ff78e0">&#9670;&#160;</a></span>operator|() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1async_1_1sharedFuture.html">async::sharedFuture</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe operator for chaining computations on sharedFuture. </p>
<p>This operator dynamically attaches a new callback to an already running sharedFuture. Unlike lazy task builders, the continuation is immediately scheduled to run once the sharedFuture produces a value. This makes it possible to share and extend asynchronous results across multiple consumers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Result type of the sharedFuture </td></tr>
    <tr><td class="paramname">Callback</td><td>Callable type, must accept T const&amp; or T (depending on design) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>Source sharedFuture containing the asynchronous result </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to process the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new future holding the result of the callback </dd></dl>

</div>
</div>
<a id="a8799c0ea3948308bfc84b56f2c7b6cbe" name="a8799c0ea3948308bfc84b56f2c7b6cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8799c0ea3948308bfc84b56f2c7b6cbe">&#9670;&#160;</a></span>operator|() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1async_1_1sharedFuture.html">async::sharedFuture</a>&lt; void &gt;&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe operator specialization for sharedFuture&lt;void&gt; </p>
<p>This operator dynamically attaches a new callback to an already running sharedFuture&lt;void&gt;. The callback will be executed once the asynchronous task completes. Since sharedFuture can be copied, multiple consumers can each dynamically attach their own continuations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Callback</td><td>Callable type, must accept no arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>Source sharedFuture&lt;void&gt; representing completion of an asynchronous task </td></tr>
    <tr><td class="paramname">c</td><td>Callback function to execute after completion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new future holding the result of the callback </dd></dl>

</div>
</div>
<a id="ab4af4e6831bcb96b1bfa50c9680e1459" name="ab4af4e6831bcb96b1bfa50c9680e1459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4af4e6831bcb96b1bfa50c9680e1459">&#9670;&#160;</a></span>operator|() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbs</td><td>The left <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
    <tr><td class="paramname">rbs</td><td>The right <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the OR operation. </dd></dl>

</div>
</div>
<a id="ace0b933d9e66dcd0b8f443fa0c38e122" name="ace0b933d9e66dcd0b8f443fa0c38e122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0b933d9e66dcd0b8f443fa0c38e122">&#9670;&#160;</a></span>operator|() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1genPipe.html">genPipe</a>&lt; F &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipe operator for generator operations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The generator element type. </td></tr>
    <tr><td class="paramname">F</td><td>The pipe operation type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The source generator. </td></tr>
    <tr><td class="paramname">p</td><td>The pipe operation to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of applying the pipe operation to the generator.</dd></dl>
<p>Enables fluent chaining of generator operations using the | operator.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> processed = source_generator</div>
<div class="line">    | <a class="code hl_function" href="namespaceoriginal.html#aba2944d86814f3187bc93fcba4dcc9ad">transforms</a>(transformer)</div>
<div class="line">    | <a class="code hl_function" href="namespaceoriginal.html#a3bb963df451f2091ae65a71e792c96a5">filters</a>(predicate);</div>
<div class="ttc" id="anamespaceoriginal_html_aba2944d86814f3187bc93fcba4dcc9ad"><div class="ttname"><a href="namespaceoriginal.html#aba2944d86814f3187bc93fcba4dcc9ad">original::transforms</a></div><div class="ttdeci">auto transforms(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c) -&gt; coroutine::generator&lt; std::invoke_result_t&lt; Callback, TYPE &gt; &gt;</div><div class="ttdoc">Transforms generator elements using a callable.</div><div class="ttdef"><b>Definition</b> generators.h:686</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a211e12b568c0705c118b16616ea931ef" name="a211e12b568c0705c118b16616ea931ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211e12b568c0705c118b16616ea931ef">&#9670;&#160;</a></span>operator||() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OR operator between filter and <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a5022994e6fe02721e521a9a0edf56901" name="a5022994e6fe02721e521a9a0edf56901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5022994e6fe02721e521a9a0edf56901">&#9670;&#160;</a></span>operator||() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create OR <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> from two filters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>First filter operand </td></tr>
    <tr><td class="paramname">f2</td><td>Second filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> with OR operation </dd></dl>

</div>
</div>
<a id="a9b99c956ab1ee40f5b50ec2422e5c7d9" name="a9b99c956ab1ee40f5b50ec2422e5c7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b99c956ab1ee40f5b50ec2422e5c7d9">&#9670;&#160;</a></span>operator||() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; original::operator|| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filterStream.html">filterStream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1filter.html">filter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OR operator between <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> and filter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ofs</td><td><a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> operand </td></tr>
    <tr><td class="paramname">f</td><td>Filter operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New combined <a class="el" href="classoriginal_1_1filterStream.html" title="Composite filter builder with logical operator chaining.">filterStream</a> </dd></dl>

</div>
</div>
<a id="a7c9d181a8e2dbc5b413f5484c4cf44da" name="a7c9d181a8e2dbc5b413f5484c4cf44da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9d181a8e2dbc5b413f5484c4cf44da">&#9670;&#160;</a></span>operator~()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ALLOC_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; original::operator~ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoriginal_1_1bitSet.html">bitSet</a>&lt; ALLOC_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>bs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>The <a class="el" href="classoriginal_1_1bitSet.html" title="A class representing a set of bits, offering functionality to manipulate and query individual bits.">bitSet</a> to negate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the NOT operation. </dd></dl>

</div>
</div>
<a id="a4527274cfb7fc9519d858ba76cdf0c2f" name="a4527274cfb7fc9519d858ba76cdf0c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4527274cfb7fc9519d858ba76cdf0c2f">&#9670;&#160;</a></span>position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> original::position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the position of the first element satisfying a predicate. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The generator to search. </td></tr>
    <tr><td class="paramname">c</td><td>The search predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first matching element, or the total count if not found.</dd></dl>
<p>Returns the 0-based index of the first element that satisfies the predicate. If no element matches, returns the total number of elements processed.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{10, 20, 30, 40};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> pos = <a class="code hl_function" href="namespaceoriginal.html#a4527274cfb7fc9519d858ba76cdf0c2f">position</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x &gt; 25; });  <span class="comment">// Returns 2</span></div>
<div class="ttc" id="anamespaceoriginal_html_a4527274cfb7fc9519d858ba76cdf0c2f"><div class="ttname"><a href="namespaceoriginal.html#a4527274cfb7fc9519d858ba76cdf0c2f">original::position</a></div><div class="ttdeci">u_integer position(coroutine::generator&lt; TYPE &gt; gen, Callback &amp;&amp;c)</div><div class="ttdoc">Finds the position of the first element satisfying a predicate.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab1ba1d14dd3063cd86d2b28662b0de1d" name="ab1ba1d14dd3063cd86d2b28662b0de1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba1d14dd3063cd86d2b28662b0de1d">&#9670;&#160;</a></span>position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::position </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a position-finding pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The predicate function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The search predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that finds the position of the first matching element.</dd></dl>
<p>Factory function for creating position-finding operations. </p>

</div>
</div>
<a id="ac9c4cc6e557e2b2a8d86f3ec463ab20a" name="ac9c4cc6e557e2b2a8d86f3ec463ab20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c4cc6e557e2b2a8d86f3ec463ab20a">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto original::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga93c0703adcef0d6e6c1a35f44c357a24">floating</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a>&#160;</td>
          <td class="paramname"><em>exp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of raising a base to an exponent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base value. </td></tr>
    <tr><td class="paramname">exp</td><td>The exponent value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of <code>base</code> raised to the power of <code>exp</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classoriginal_1_1valueError.html" title="Exception for invalid parameter values.">valueError</a></td><td>If <code>base</code> is 0 and <code>exp</code> is less than or equal to 0.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs exponentiation by iterating <code>exp</code> times and multiplying the base. If <code>exp</code> is negative, it computes the reciprocal of the result. An exception is thrown if <code>base</code> is 0 and <code>exp</code> is non-positive.</p>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordtype">double</span> base = 2.0;</div>
<div class="line"><span class="keywordtype">int</span> exp = 3;</div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code hl_function" href="namespaceoriginal.html#ac9c4cc6e557e2b2a8d86f3ec463ab20a">original::pow</a>(base, exp); <span class="comment">// result will be 8.0</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For negative exponent:</span></div>
<div class="line">exp = -2;</div>
<div class="line">result = <a class="code hl_function" href="namespaceoriginal.html#ac9c4cc6e557e2b2a8d86f3ec463ab20a">original::pow</a>(base, exp); <span class="comment">// result will be 0.25</span></div>
<div class="ttc" id="anamespaceoriginal_html_ac9c4cc6e557e2b2a8d86f3ec463ab20a"><div class="ttname"><a href="namespaceoriginal.html#ac9c4cc6e557e2b2a8d86f3ec463ab20a">original::pow</a></div><div class="ttdeci">floating pow(floating base, integer exp)</div><div class="ttdoc">Returns the result of raising a base to an exponent.</div><div class="ttdef"><b>Definition</b> maths.h:159</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a17552f40eb8b0c25f10f54d13fcf6c2e" name="a17552f40eb8b0c25f10f54d13fcf6c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17552f40eb8b0c25f10f54d13fcf6c2e">&#9670;&#160;</a></span>rangesOf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral INTEGER = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; INTEGER &gt; original::rangesOf </td>
          <td>(</td>
          <td class="paramtype">INTEGER&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INTEGER&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a sequence of integers from <code>start</code> to <code>end</code> (exclusive) with a given <code>steps</code>. </p>
<p>This function returns a coroutine-based generator that yields integer values starting from <code>start</code>, incrementing or decrementing by <code>steps</code>, until <code>end</code> is reached (exclusive).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">INTEGER</td><td>The integer type (defaults to <code>int</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting value. </td></tr>
    <tr><td class="paramname">end</td><td>The ending value (exclusive). </td></tr>
    <tr><td class="paramname">steps</td><td>The step size between values (default is 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator that yields the sequence of integers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>steps</code> is zero or the range is invalid (e.g., start &gt; end with positive step), the generator will immediately complete without yielding any values.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Example usage:</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : <a class="code hl_namespace" href="namespaceoriginal.html">original</a>::<a class="code hl_function" href="namespaceoriginal.html#a17552f40eb8b0c25f10f54d13fcf6c2e">rangesOf</a>(1, 5)) {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// Output: 1 2 3 4</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i : <a class="code hl_namespace" href="namespaceoriginal.html">original</a>::<a class="code hl_function" href="namespaceoriginal.html#a17552f40eb8b0c25f10f54d13fcf6c2e">rangesOf</a>(5, 1, -1)) {</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; <span class="comment">// Output: 5 4 3 2</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceoriginal_html"><div class="ttname"><a href="namespaceoriginal.html">original</a></div><div class="ttdoc">Main namespace for the project Original.</div><div class="ttdef"><b>Definition</b> algorithms.h:21</div></div>
<div class="ttc" id="anamespaceoriginal_html_a17552f40eb8b0c25f10f54d13fcf6c2e"><div class="ttname"><a href="namespaceoriginal.html#a17552f40eb8b0c25f10f54d13fcf6c2e">original::rangesOf</a></div><div class="ttdeci">coroutine::generator&lt; INTEGER &gt; rangesOf(INTEGER start, INTEGER end, INTEGER steps=1)</div><div class="ttdoc">Generates a sequence of integers from start to end (exclusive) with a given steps.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4e51ab2bbc2425bdb4429bd3b2e87a14" name="a4e51ab2bbc2425bdb4429bd3b2e87a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e51ab2bbc2425bdb4429bd3b2e87a14">&#9670;&#160;</a></span>reverseIndexSequenceImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;u_integer... Indices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">consteval auto original::reverseIndexSequenceImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1indexSequence.html">indexSequence</a>&lt; Indices... &gt;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation detail for reversing an index sequence. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Indices</td><td>Sequence indices to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The index sequence to reverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reversed index sequence </dd></dl>

</div>
</div>
<a id="a18ae078f895b8100b5aed3e3b26f156e" name="a18ae078f895b8100b5aed3e3b26f156e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ae078f895b8100b5aed3e3b26f156e">&#9670;&#160;</a></span>skip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; original::skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skips the first n elements of a generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The source generator. </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding elements after the first n.</dd></dl>
<p>Discards the first n elements and yields the remainder of the sequence.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> val : <a class="code hl_function" href="namespaceoriginal.html#a18ae078f895b8100b5aed3e3b26f156e">skip</a>(gen, 2)) {</div>
<div class="line">    <span class="comment">// Yields: 3, 4, 5</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceoriginal_html_a18ae078f895b8100b5aed3e3b26f156e"><div class="ttname"><a href="namespaceoriginal.html#a18ae078f895b8100b5aed3e3b26f156e">original::skip</a></div><div class="ttdeci">coroutine::generator&lt; TYPE &gt; skip(coroutine::generator&lt; TYPE &gt; gen, u_integer n)</div><div class="ttdoc">Skips the first n elements of a generator.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adf5940d515f98ed643fe39e2579a28cc" name="adf5940d515f98ed643fe39e2579a28cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5940d515f98ed643fe39e2579a28cc">&#9670;&#160;</a></span>skip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a skip pipe operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that skips the first n elements.</dd></dl>
<p>Factory function for creating skip operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="a2702810184338d29e82f22af59d7dbd3" name="a2702810184338d29e82f22af59d7dbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2702810184338d29e82f22af59d7dbd3">&#9670;&#160;</a></span>take() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt; original::take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes the first n elements from a generator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The source generator. </td></tr>
    <tr><td class="paramname">n</td><td>Number of elements to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding at most n elements.</dd></dl>
<p>Limits the output to the first n elements of the input generator. Stops early if the input generator has fewer than n elements.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> val : <a class="code hl_function" href="namespaceoriginal.html#a2702810184338d29e82f22af59d7dbd3">take</a>(gen, 3)) {</div>
<div class="line">    <span class="comment">// Yields: 1, 2, 3</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceoriginal_html_a2702810184338d29e82f22af59d7dbd3"><div class="ttname"><a href="namespaceoriginal.html#a2702810184338d29e82f22af59d7dbd3">original::take</a></div><div class="ttdeci">coroutine::generator&lt; TYPE &gt; take(coroutine::generator&lt; TYPE &gt; gen, u_integer n)</div><div class="ttdoc">Takes the first n elements from a generator.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7ac4116340b45e469d5a889a065643c6" name="a7ac4116340b45e469d5a889a065643c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac4116340b45e469d5a889a065643c6">&#9670;&#160;</a></span>take() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::take </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a take pipe operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that takes the first n elements.</dd></dl>
<p>Factory function for creating take operations that can be used with the pipe operator. </p>

</div>
</div>
<a id="aba2944d86814f3187bc93fcba4dcc9ad" name="aba2944d86814f3187bc93fcba4dcc9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2944d86814f3187bc93fcba4dcc9ad">&#9670;&#160;</a></span>transforms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TYPE , typename Callback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::transforms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; TYPE &gt;&#160;</td>
          <td class="paramname"><em>gen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt;std::invoke_result_t&lt;Callback, TYPE&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms generator elements using a callable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>The input element type. </td></tr>
    <tr><td class="paramname">Callback</td><td>The transformation function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen</td><td>The source generator. </td></tr>
    <tr><td class="paramname">c</td><td>The transformation callable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding transformed elements.</dd></dl>
<p>Applies a transformation function to each element of the input generator, producing a new generator with the transformed values.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> gen = vec.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> squared = <a class="code hl_function" href="namespaceoriginal.html#aba2944d86814f3187bc93fcba4dcc9ad">transforms</a>(gen, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; });</div>
<div class="line"><span class="comment">// Yields: 1, 4, 9</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1671ab76b31ddaa0cb58adae7f23195b" name="a1671ab76b31ddaa0cb58adae7f23195b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1671ab76b31ddaa0cb58adae7f23195b">&#9670;&#160;</a></span>transforms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::transforms </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a transform pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The transformation function type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The transformation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that applies the transformation.</dd></dl>
<p>Factory function for creating transform operations that can be used with the pipe operator.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> double_transform = <a class="code hl_function" href="namespaceoriginal.html#aba2944d86814f3187bc93fcba4dcc9ad">transforms</a>([](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; });</div>
<div class="line"><span class="keyword">auto</span> result = gen | double_transform;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae0c7c44f58fe2c19b44736b606159f8d" name="ae0c7c44f58fe2c19b44736b606159f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c7c44f58fe2c19b44736b606159f8d">&#9670;&#160;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; <a class="el" href="classoriginal_1_1couple.html">couple</a>&lt; T, U &gt; &gt; original::zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>gen1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>gen2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips two generators into pairs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of first generator elements. </td></tr>
    <tr><td class="paramname">U</td><td>Type of second generator elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen1</td><td>First generator. </td></tr>
    <tr><td class="paramname">gen2</td><td>Second generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A generator yielding couples of elements from both generators.</dd></dl>
<p>Pairs elements from two generators positionally. Stops when either generator is exhausted.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> vec1 = <a class="code hl_class" href="classoriginal_1_1vector.html">vector</a>{1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> vec2 = vector{<span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>};</div>
<div class="line"><span class="keyword">auto</span> gen1 = vec1.<a class="code hl_function" href="classoriginal_1_1iterable.html#ae6819ade022d19dcbf5c06f046caa2dc">generator</a>();</div>
<div class="line"><span class="keyword">auto</span> gen2 = vec2.generator();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> [num, ch] : <a class="code hl_function" href="namespaceoriginal.html#ae0c7c44f58fe2c19b44736b606159f8d">zip</a>(gen1, gen2)) {</div>
<div class="line">    <span class="comment">// Yields: (1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceoriginal_html_ae0c7c44f58fe2c19b44736b606159f8d"><div class="ttname"><a href="namespaceoriginal.html#ae0c7c44f58fe2c19b44736b606159f8d">original::zip</a></div><div class="ttdeci">coroutine::generator&lt; couple&lt; T, U &gt; &gt; zip(coroutine::generator&lt; T &gt; gen1, coroutine::generator&lt; U &gt; gen2)</div><div class="ttdoc">Zips two generators into pairs.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2d66ded42ac114bcf9d5fd5ea537c0b9" name="a2d66ded42ac114bcf9d5fd5ea537c0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d66ded42ac114bcf9d5fd5ea537c0b9">&#9670;&#160;</a></span>zipWith()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto original::zipWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoriginal_1_1coroutine_1_1generator.html">coroutine::generator</a>&lt; U &gt;&#160;</td>
          <td class="paramname"><em>gen2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a zipWith pipe operation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td>The element type of the second generator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gen2</td><td>The generator to zip with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classoriginal_1_1genPipe.html" title="Pipe adapter for generator operations to enable fluent chaining.">genPipe</a> that zips generators.</dd></dl>
<p>Factory function for creating zip operations that can be used with the pipe operator. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="abd47f617dbcb368ac64505354d1a35fe" name="abd47f617dbcb368ac64505354d1a35fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd47f617dbcb368ac64505354d1a35fe">&#9670;&#160;</a></span>E</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__TypeDefinitions.html#gab97e5374482de5baaded9620b95d5351">l_floating</a> original::E = 2.7182818284590452353602874713526624977572470937000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mathematical constant E (Euler's number). </p>
<p>This is the base of the natural logarithm, approximately equal to 2.71828. It is used in various mathematical, scientific, and engineering applications, particularly in exponential growth and decay models, as well as in complex analysis. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_2home_2runner_2work_2original_2original_2src_2core_2tuple_8h-example.html#a1">/home/runner/work/original/original/src/core/tuple.h</a>.</dd>
</dl>

</div>
</div>
<a id="ab91dfcaba25870b33f8f72edcc791415" name="ab91dfcaba25870b33f8f72edcc791415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91dfcaba25870b33f8f72edcc791415">&#9670;&#160;</a></span>PI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__TypeDefinitions.html#gab97e5374482de5baaded9620b95d5351">l_floating</a> original::PI = 3.1415926535897932384626433832795028841971693993751</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mathematical constant PI (π). </p>
<p>This is the ratio of a circle's circumference to its diameter, approximately equal to 3.14159. It is used in geometry, trigonometry, and many other mathematical fields, especially when dealing with circular or spherical shapes. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
