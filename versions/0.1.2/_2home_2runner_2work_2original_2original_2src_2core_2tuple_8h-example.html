<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ORIGINAL: /home/runner/work/original/original/src/core/tuple.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ORIGINAL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">/home/runner/work/original/original/src/core/tuple.h</div></div>
</div><!--header-->
<div class="contents">
<p>original::tuple&lt;int, std::string&gt; t(10, "hi"); int x = t.get&lt;0&gt;(); // access t.set&lt;1&gt;(std::string("hello")); // modify</p>
<p>const auto&amp; [a, b] = t; // structured binding</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef TUPLE_H</span></div>
<div class="line"><span class="preprocessor">#define TUPLE_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="printable_8h.html">printable.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="comparable_8h.html">comparable.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="couple_8h.html">couple.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="types_8h.html">types.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceoriginal.html">original</a> {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">    <span class="keyword">class </span>tuple final : <span class="keyword">public</span> printable, <span class="keyword">public</span> comparable&lt;tuple&lt;TYPES...&gt;&gt; {</div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">constexpr</span> <a id="a0" name="a0"></a><a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> SIZE = <span class="keyword">sizeof</span>...(TYPES);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> I, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line">        <span class="keyword">class </span>tupleImpl;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line">        <span class="keyword">class </span>tupleImpl&lt;I, T&gt; : <span class="keyword">public</span> printable, <span class="keyword">public</span> comparable&lt;tupleImpl&lt;I, T&gt;&gt; {</div>
<div class="line">            T cur_elem;  </div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="keyword">explicit</span> tupleImpl(<span class="keyword">const</span> T&amp; cur = T{});</div>
<div class="line">            tupleImpl(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line">            tupleImpl(<span class="keyword">const</span> tupleImpl&amp; other);</div>
<div class="line">            tupleImpl&amp; operator=(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; get() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line">            <span class="keyword">auto</span>&amp; get();</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF, <span class="keyword">typename</span> E&gt;</div>
<div class="line">            <span class="keywordtype">void</span> set(<span class="keyword">const</span> <a id="a1" name="a1"></a><a class="code hl_variable" href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">E</a>&amp; e);</div>
<div class="line"> </div>
<div class="line">            <a id="a2" name="a2"></a><a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> compareTo(<span class="keyword">const</span> tupleImpl&amp; other) <span class="keyword">const override</span>;</div>
<div class="line">            std::string <a id="a3" name="a3"></a><a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">toString</a>(<span class="keywordtype">bool</span> enter) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">friend</span> <span class="keyword">class </span>tuple;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line">        <span class="keyword">class </span>tupleImpl&lt;I, T, TS&gt; : <span class="keyword">public</span> printable, <span class="keyword">public</span> comparable&lt;tupleImpl&lt;I, T, TS&gt;&gt; {</div>
<div class="line">            T cur_elem;                  </div>
<div class="line">            tupleImpl&lt;I + 1, TS&gt; next;   </div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="keyword">explicit</span> tupleImpl(<span class="keyword">const</span> T&amp; cur = T{}, <span class="keyword">const</span> TS&amp; next_elems = TS{});</div>
<div class="line">            tupleImpl(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line">            tupleImpl(<span class="keyword">const</span> tupleImpl&amp; other);</div>
<div class="line">            tupleImpl&amp; operator=(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; get() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line">            <span class="keyword">auto</span>&amp; get();</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF, <span class="keyword">typename</span> E&gt;</div>
<div class="line">            <span class="keywordtype">void</span> set(<span class="keyword">const</span> <a class="code hl_variable" href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">E</a>&amp; e);</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> compareTo(<span class="keyword">const</span> tupleImpl&amp; other) <span class="keyword">const override</span>;</div>
<div class="line">            std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">toString</a>(<span class="keywordtype">bool</span> enter) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">friend</span> <span class="keyword">class </span>tuple;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line">        <span class="keyword">class </span>tupleImpl&lt;I, T, TS...&gt; : <span class="keyword">public</span> printable, <span class="keyword">public</span> comparable&lt;tupleImpl&lt;I, T, TS...&gt;&gt; {</div>
<div class="line">            T cur_elem;                     </div>
<div class="line">            tupleImpl&lt;I + 1, TS...&gt; next;   </div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">            <span class="keyword">explicit</span> tupleImpl(<span class="keyword">const</span> T&amp; cur, <span class="keyword">const</span> TS&amp;... next_elems);</div>
<div class="line">            <span class="keyword">explicit</span> tupleImpl(<span class="keyword">const</span> T&amp; cur = T{}, <span class="keyword">const</span> tupleImpl&lt;I + 1, TS...&gt;&amp; nt = tupleImpl&lt;I + 1, TS...&gt;{});</div>
<div class="line">            tupleImpl(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line">            tupleImpl(<span class="keyword">const</span> tupleImpl&amp; other);</div>
<div class="line">            tupleImpl&amp; operator=(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; get() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line">            <span class="keyword">auto</span>&amp; get();</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger I_DIFF, <span class="keyword">typename</span> E&gt;</div>
<div class="line">            <span class="keywordtype">void</span> set(<span class="keyword">const</span> <a class="code hl_variable" href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">E</a>&amp; e);</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> compareTo(<span class="keyword">const</span> tupleImpl&amp; other) <span class="keyword">const override</span>;</div>
<div class="line">            std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">toString</a>(<span class="keywordtype">bool</span> enter) <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">friend</span> <span class="keyword">class </span>tuple;</div>
<div class="line">        };</div>
<div class="line"> </div>
<div class="line">        tupleImpl&lt;0, TYPES...&gt; elems;  </div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>... IDX_S, <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> BEGIN_IDX&gt;</div>
<div class="line">        <span class="keyword">auto</span> _slice(std::integer_sequence&lt;u_integer, IDX_S...&gt; indexes,</div>
<div class="line">                    std::integral_constant&lt;u_integer, BEGIN_IDX&gt; begin) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... O_TYPES, <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>... T_SIZE, <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>... O_SIZE&gt;</div>
<div class="line">        tuple&lt;TYPES..., O_TYPES...&gt; _concat(<span class="keyword">const</span> tuple&lt;O_TYPES...&gt;&amp; other,</div>
<div class="line">                                            std::integer_sequence&lt;u_integer, T_SIZE...&gt; ts,</div>
<div class="line">                                            std::integer_sequence&lt;u_integer, O_SIZE...&gt; os) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">explicit</span> tuple();</div>
<div class="line">        <span class="keyword">explicit</span> tuple(<span class="keyword">const</span> TYPES&amp;... e);</div>
<div class="line">        tuple(<span class="keyword">const</span> tuple&amp; other);</div>
<div class="line">        tuple&amp; operator=(<span class="keyword">const</span> tuple&amp; other);</div>
<div class="line">        tuple(tuple&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line">        tuple&amp; operator=(tuple&amp;&amp; other) <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">consteval</span> <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a> size() <span class="keyword">noexcept</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger IDX&gt;</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; get() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger IDX&gt;</div>
<div class="line">        <span class="keyword">auto</span>&amp; get();</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger IDX, <span class="keyword">typename</span> E&gt;</div>
<div class="line">        tuple&amp; set(<span class="keyword">const</span> <a class="code hl_variable" href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">E</a>&amp; e);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;u_<span class="keywordtype">int</span>eger BEGIN_IDX, u_<span class="keywordtype">int</span>eger N_ELEMS&gt;</div>
<div class="line">        <span class="keyword">auto</span> slice() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a> compareTo(<span class="keyword">const</span> tuple&amp; other) <span class="keyword">const override</span>;</div>
<div class="line">        std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">toString</a>(<span class="keywordtype">bool</span> enter) <span class="keyword">const override</span>;</div>
<div class="line">        std::string <a id="a4" name="a4"></a><a class="code hl_function" href="classoriginal_1_1tuple.html#a8af22e6508a586d5eb344175509e4230">className</a>() <span class="keyword">const override</span>;</div>
<div class="line"> </div>
<div class="line">        ~tuple() <span class="keyword">override</span> = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F_TYPE, <span class="keyword">typename</span> S_TYPE&gt;</div>
<div class="line">        <span class="keyword">friend</span> tuple&lt;F_TYPE, S_TYPE&gt; makeTuple(<span class="keyword">const</span> couple&lt;F_TYPE, S_TYPE&gt;&amp; cp);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... L_TYPES, <span class="keyword">typename</span>... R_TYPES&gt;</div>
<div class="line">        <span class="keyword">friend</span> tuple&lt;L_TYPES..., R_TYPES...&gt; operator+(<span class="keyword">const</span> tuple&lt;L_TYPES...&gt;&amp; lt, <span class="keyword">const</span> tuple&lt;R_TYPES...&gt;&amp; rt);</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F_TYPE, <span class="keyword">typename</span> S_TYPE&gt;</div>
<div class="line">    tuple&lt;F_TYPE, S_TYPE&gt; makeTuple(<span class="keyword">const</span> couple&lt;F_TYPE, S_TYPE&gt;&amp; cp);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... L_TYPES, <span class="keyword">typename</span>... R_TYPES&gt;</div>
<div class="line">    tuple&lt;L_TYPES..., R_TYPES...&gt; <a id="a5" name="a5"></a><a class="code hl_function" href="namespaceoriginal.html#a176d8ed479959a50d637c2ee6900a159">operator+</a>(<span class="keyword">const</span> tuple&lt;L_TYPES...&gt;&amp; lt, <span class="keyword">const</span> tuple&lt;R_TYPES...&gt;&amp; rt);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>std {</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">    <span class="keyword">struct </span>tuple_size&lt;<a class="code hl_namespace" href="namespaceoriginal.html">original</a>::tuple&lt;TYPES...&gt;&gt; <span class="comment">//NOLINT</span></div>
<div class="line">            : std::integral_constant&lt;std::size_t, sizeof...(TYPES)&gt; {};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">    <span class="keyword">struct </span>tuple_element&lt;I, <a class="code hl_namespace" href="namespaceoriginal.html">original</a>::tuple&lt;TYPES...&gt;&gt; { <span class="comment">//NOLINT</span></div>
<div class="line">        <span class="keyword">using </span>type = std::tuple_element_t&lt;I, std::tuple&lt;TYPES...&gt;&gt;;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp; <a id="a6" name="a6"></a><a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>(<a id="_a7" name="_a7"></a><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;</a>&amp; t) <span class="keyword">noexcept</span>; <span class="comment">//NOLINT</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>(<span class="keyword">const</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;</a>&amp; t) <span class="keyword">noexcept</span>; <span class="comment">//NOLINT</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>(<a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;</a>&amp;&amp; t) <span class="keyword">noexcept</span>; <span class="comment">//NOLINT</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::tupleImpl</a>(<span class="keyword">const</span> T&amp; cur)</div>
<div class="line">    : cur_elem(cur) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::tupleImpl</a>(tupleImpl&amp;&amp; other) noexcept</div>
<div class="line">    : cur_elem(std::move(other.cur_elem)) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::tupleImpl</a>(<span class="keyword">const</span> tupleImpl&amp; other)</div>
<div class="line">    : cur_elem(other.cur_elem) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::operator=</a>(tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span> -&gt; tupleImpl&amp;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other)</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    cur_elem = std::move(other.cur_elem);</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::get</a>()<span class="keyword"> const </span>{</div>
<div class="line">    staticError&lt;outOfBoundError, (I_DIFF &gt; 0)&gt;::asserts();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> cur_elem;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line"><span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::get</a>() {</div>
<div class="line">    staticError&lt;outOfBoundError, (I_DIFF &gt; 0)&gt;::asserts();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> cur_elem;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF, <span class="keyword">typename</span> E&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::set</a>(<span class="keyword">const</span> E&amp; e) {</div>
<div class="line">    staticError&lt;outOfBoundError, (I_DIFF &gt; 0)&gt;::asserts();</div>
<div class="line">    staticError&lt;valueError, !std::is_convertible_v&lt;E, T&gt;&gt;::asserts();</div>
<div class="line"> </div>
<div class="line">    cur_elem = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(e);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::compareTo</a>(<span class="keyword">const</span> tupleImpl&amp; other) <span class="keyword">const</span> -&gt; <a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (Comparable&lt;T&gt;){</div>
<div class="line">        <span class="keywordflow">if</span> (cur_elem != other.cur_elem)</div>
<div class="line">            <span class="keywordflow">return</span> cur_elem &lt; other.cur_elem ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T&gt;</div>
<div class="line">std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T&gt;::toString</a>(<span class="keywordtype">bool</span> enter)<span class="keyword"> const </span>{</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I != 0)</div>
<div class="line">        ss &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    ss &lt;&lt; formatString(cur_elem);</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::tupleImpl</a>(<span class="keyword">const</span> T&amp; cur, <span class="keyword">const</span> TS&amp; next_elems)</div>
<div class="line">    : cur_elem(cur), next(next_elems) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::tupleImpl</a>(tupleImpl&amp;&amp; other) noexcept</div>
<div class="line">    : cur_elem(std::move(other.cur_elem)), next(std::move(other.next)) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::tupleImpl</a>(<span class="keyword">const</span> tupleImpl&amp; other)</div>
<div class="line">    : cur_elem(other.cur_elem), next(other.next) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::operator=</a>(</div>
<div class="line">    tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span> -&gt; tupleImpl&amp;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other)</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    cur_elem = std::move(other.cur_elem);</div>
<div class="line">    next = std::move(other.next);</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::get</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I_DIFF == 0){</div>
<div class="line">        <span class="keywordflow">return</span> cur_elem;</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        <span class="keywordflow">return</span> next.template <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>&lt;I_DIFF - 1&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line"><span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::get</a>() {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I_DIFF == 0){</div>
<div class="line">        <span class="keywordflow">return</span> cur_elem;</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        <span class="keywordflow">return</span> next.template <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>&lt;I_DIFF - 1&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF, <span class="keyword">typename</span> E&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::set</a>(<span class="keyword">const</span> E&amp; e) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I_DIFF == 0){</div>
<div class="line">        staticError&lt;valueError, !std::is_convertible_v&lt;E, T&gt;&gt;::asserts();</div>
<div class="line"> </div>
<div class="line">        cur_elem = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(e);</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        next.template set&lt;I_DIFF - 1, <a class="code hl_variable" href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">E</a>&gt;(e);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::compareTo</a>(</div>
<div class="line">    <span class="keyword">const</span> tupleImpl&amp; other) <span class="keyword">const</span> -&gt; <a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">integer</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (Comparable&lt;T&gt;){</div>
<div class="line">        <span class="keywordflow">if</span> (cur_elem != other.cur_elem)</div>
<div class="line">            <span class="keywordflow">return</span> cur_elem &lt; other.cur_elem ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> next.compareTo(other.next);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I, <span class="keyword">typename</span> T, <span class="keyword">typename</span> TS&gt;</div>
<div class="line">std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS&gt;::toString</a>(<span class="keywordtype">bool</span> enter)<span class="keyword"> const </span>{</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I != 0)</div>
<div class="line">        ss &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    ss &lt;&lt; formatString(cur_elem);</div>
<div class="line">    ss &lt;&lt; formatString(next);</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::tupleImpl</a>(<span class="keyword">const</span> T&amp; cur, <span class="keyword">const</span> TS&amp;... next_elems)</div>
<div class="line">    : cur_elem(cur), next(next_elems...) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::tupleImpl</a>(<span class="keyword">const</span> T&amp; cur, <span class="keyword">const</span> tupleImpl&lt;I + 1, TS...&gt;&amp; nt)</div>
<div class="line">    : cur_elem(cur), next(nt) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::tupleImpl</a>(tupleImpl&amp;&amp; other) noexcept</div>
<div class="line">    : cur_elem(std::move(other.cur_elem)), next(std::move(other.next)) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::tupleImpl</a>(<span class="keyword">const</span> tupleImpl&amp; other)</div>
<div class="line">    : cur_elem(other.cur_elem), next(other.next) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::operator=</a>(</div>
<div class="line">    tupleImpl&amp;&amp; other) <span class="keyword">noexcept</span> -&gt; tupleImpl&amp;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other)</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    cur_elem = std::move(other.cur_elem);</div>
<div class="line">    next = std::move(other.next);</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::get</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I_DIFF == 0){</div>
<div class="line">        <span class="keywordflow">return</span> cur_elem;</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        <span class="keywordflow">return</span> next.template <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>&lt;I_DIFF - 1&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF&gt;</div>
<div class="line"><span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::get</a>() {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I_DIFF == 0){</div>
<div class="line">        <span class="keywordflow">return</span> cur_elem;</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        <span class="keywordflow">return</span> next.template <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">get</a>&lt;I_DIFF - 1&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger I_DIFF, <span class="keyword">typename</span> E&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::set</a>(<span class="keyword">const</span> E&amp; e) {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I_DIFF == 0){</div>
<div class="line">        staticError&lt;valueError, !std::is_convertible_v&lt;E, T&gt;&gt;::asserts();</div>
<div class="line"> </div>
<div class="line">        cur_elem = <span class="keyword">static_cast&lt;</span>T<span class="keyword">&gt;</span>(e);</div>
<div class="line">    } <span class="keywordflow">else</span>{</div>
<div class="line">        next.template set&lt;I_DIFF - 1, <a class="code hl_variable" href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">E</a>&gt;(e);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line"><a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">original::integer</a></div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::compareTo</a>(<span class="keyword">const</span> tupleImpl&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (Comparable&lt;T&gt;){</div>
<div class="line">        <span class="keywordflow">if</span> (cur_elem != other.cur_elem)</div>
<div class="line">            <span class="keywordflow">return</span> cur_elem &lt; other.cur_elem ? -1 : 1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> next.compareTo(other.next);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> I, <span class="keyword">typename</span> T, <span class="keyword">typename</span>... TS&gt;</div>
<div class="line">std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">original::tuple&lt;TYPES...&gt;::tupleImpl&lt;I, T, TS...&gt;::toString</a>(<span class="keywordtype">bool</span> enter)<span class="keyword"> const </span>{</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (I != 0)</div>
<div class="line">        ss &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">    ss &lt;&lt; formatString(cur_elem);</div>
<div class="line">    ss &lt;&lt; formatString(next);</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a>... IDX_S, <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> BEGIN_IDX&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::_slice</a>(std::integer_sequence&lt;u_integer, IDX_S...&gt;,</div>
<div class="line">                                       std::integral_constant&lt;u_integer, BEGIN_IDX&gt;)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> tuple&lt;<span class="keyword">decltype</span>(this-&gt;get&lt;BEGIN_IDX + IDX_S&gt;())...&gt;(this-&gt;get&lt;BEGIN_IDX + IDX_S&gt;()...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... O_TYPES, <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a>... T_SIZE, <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a>... O_SIZE&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple</a>&lt;TYPES..., O_TYPES...&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::_concat</a>(<span class="keyword">const</span> tuple&lt;O_TYPES...&gt; &amp;other,</div>
<div class="line">                                   std::integer_sequence&lt;u_integer, T_SIZE...&gt;,</div>
<div class="line">                                   std::integer_sequence&lt;u_integer, O_SIZE...&gt;)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> tuple&lt;TYPES..., O_TYPES...&gt;{this-&gt;get&lt;T_SIZE&gt;()..., other.template get&lt;O_SIZE&gt;()...};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tuple</a>() : elems() {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tuple</a>(<span class="keyword">const</span> TYPES&amp;... e) : elems(e...) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tuple</a>(<span class="keyword">const</span> tuple&amp; other) : elems(other.elems) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple</a>&lt;TYPES...&gt;&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::operator=</a>(<span class="keyword">const</span> tuple&amp; other) {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    this-&gt;elems = other.elems;</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::tuple</a>(tuple&amp;&amp; other) noexcept</div>
<div class="line">    : elems(std::move(other.elems)) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple</a>&lt;TYPES...&gt;&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::operator=</a>(tuple&amp;&amp; other) <span class="keyword">noexcept</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    this-&gt;elems = std::move(other.elems);</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">consteval</span> <a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::size</a>() noexcept {</div>
<div class="line">    <span class="keywordflow">return</span> SIZE;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger IDX&gt;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::get</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> elems.template get&lt;IDX&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger IDX&gt;</div>
<div class="line"><span class="keyword">auto</span>&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::get</a>() {</div>
<div class="line">    <span class="keywordflow">return</span> elems.template get&lt;IDX&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger IDX, <span class="keyword">typename</span> E&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple</a>&lt;TYPES...&gt;&amp; <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::set</a>(<span class="keyword">const</span> E &amp;e) {</div>
<div class="line">    elems.template set&lt;IDX, E&gt;(e);</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">template</span>&lt;original::u_<span class="keywordtype">int</span>eger BEGIN_IDX, original::u_<span class="keywordtype">int</span>eger N_ELEMS&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::slice</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">bool</span> out_of_bound = BEGIN_IDX &gt;= SIZE || BEGIN_IDX + N_ELEMS &gt; SIZE;</div>
<div class="line">    staticError&lt;outOfBoundError, out_of_bound&gt;::asserts();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;_slice(</div>
<div class="line">            std::make_integer_sequence&lt;u_integer, N_ELEMS&gt;{},</div>
<div class="line">            std::integral_constant&lt;u_integer, BEGIN_IDX&gt;{}</div>
<div class="line">    );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><a class="code hl_typedef" href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">original::integer</a> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;::compareTo</a>(<span class="keyword">const</span> tuple&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> elems.<a id="a8" name="a8"></a>compareTo(other.elems);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">original::tuple&lt;TYPES...&gt;::toString</a>(<span class="keywordtype">bool</span> enter)<span class="keyword"> const </span>{</div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; this-&gt;className();</div>
<div class="line">    ss &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; elems &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> ss.str();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line">std::string <a class="code hl_function" href="classoriginal_1_1tuple.html#a8af22e6508a586d5eb344175509e4230">original::tuple&lt;TYPES...&gt;::className</a>()<span class="keyword"> const </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;tuple&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F_TYPE, <span class="keyword">typename</span> S_TYPE&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;F_TYPE, S_TYPE&gt;</a> original::makeTuple(<span class="keyword">const</span> couple&lt;F_TYPE, S_TYPE&gt; &amp;cp) {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;F_TYPE, S_TYPE&gt;</a>{cp.template get&lt;0&gt;(), cp.template get&lt;1&gt;()};</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... L_TYPES, <span class="keyword">typename</span>... R_TYPES&gt;</div>
<div class="line"><a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple</a>&lt;L_TYPES..., R_TYPES...&gt;</div>
<div class="line"><a class="code hl_function" href="namespaceoriginal.html#a176d8ed479959a50d637c2ee6900a159">original::operator+</a>(<span class="keyword">const</span> tuple&lt;L_TYPES...&gt; &amp;lt, <span class="keyword">const</span> tuple&lt;R_TYPES...&gt; &amp;rt) {</div>
<div class="line">    <span class="keywordflow">return</span> lt._concat(rt,</div>
<div class="line">        std::make_integer_sequence&lt;u_integer, <span class="keyword">sizeof</span>...(L_TYPES)&gt;{},</div>
<div class="line">        std::make_integer_sequence&lt;<a class="code hl_typedef" href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">u_integer</a>, <span class="keyword">sizeof</span>...(R_TYPES)&gt;{});</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp; <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">std::get</a>(<a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;</a> &amp;t) <span class="keyword">noexcept</span> { <span class="comment">//NOLINT</span></div>
<div class="line">    <span class="keywordflow">return</span> t.template get&lt;I&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">std::get</a>(<span class="keyword">const</span> <a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;</a> &amp;t) <span class="keyword">noexcept</span> { <span class="comment">//NOLINT</span></div>
<div class="line">    <span class="keywordflow">return</span> t.template get&lt;I&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;std::size_t I, <span class="keyword">typename</span>... TYPES&gt;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span>&amp;&amp; <a class="code hl_function" href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">std::get</a>(<a class="code hl_class" href="classoriginal_1_1tuple.html">original::tuple&lt;TYPES...&gt;</a> &amp;&amp;t) <span class="keyword">noexcept</span> { <span class="comment">//NOLINT</span></div>
<div class="line">    <span class="keywordflow">return</span> std::move(t.template get&lt;I&gt;());</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">//TUPLE_H</span></div>
<div class="ttc" id="aclassoriginal_1_1tuple_html"><div class="ttname"><a href="classoriginal_1_1tuple.html">original::tuple</a></div><div class="ttdoc">Container for multiple heterogeneous elements.</div><div class="ttdef"><b>Definition</b> tuple.h:53</div></div>
<div class="ttc" id="aclassoriginal_1_1tuple_html_a4bdba65409d58fcdbf76fd298a744acf"><div class="ttname"><a href="classoriginal_1_1tuple.html#a4bdba65409d58fcdbf76fd298a744acf">original::tuple::toString</a></div><div class="ttdeci">std::string toString(bool enter) const override</div><div class="ttdoc">Generates formatted string representation.</div><div class="ttdef"><b>Definition</b> tuple.h:619</div></div>
<div class="ttc" id="aclassoriginal_1_1tuple_html_a8af22e6508a586d5eb344175509e4230"><div class="ttname"><a href="classoriginal_1_1tuple.html#a8af22e6508a586d5eb344175509e4230">original::tuple::className</a></div><div class="ttdeci">std::string className() const override</div><div class="ttdoc">Gets the class name for type identification.</div><div class="ttdef"><b>Definition</b> tuple.h:627</div></div>
<div class="ttc" id="acomparable_8h_html"><div class="ttname"><a href="comparable_8h.html">comparable.h</a></div><div class="ttdoc">Interface for objects that can be compared.</div></div>
<div class="ttc" id="acouple_8h_html"><div class="ttname"><a href="couple_8h.html">couple.h</a></div><div class="ttdoc">Generic pair container implementation.</div></div>
<div class="ttc" id="acouple_8h_html_aa80128e7b1e8116b414d264264c7848f"><div class="ttname"><a href="couple_8h.html#aa80128e7b1e8116b414d264264c7848f">std::get</a></div><div class="ttdeci">constexpr auto &amp; get(original::couple&lt; F, S &gt; &amp;c) noexcept</div><div class="ttdoc">Structured binding support - get for non-const lvalue reference.</div><div class="ttdef"><b>Definition</b> couple.h:364</div></div>
<div class="ttc" id="agroup__TypeDefinitions_html_ga00034df66aefa8043fc1bf5f02ec9392"><div class="ttname"><a href="group__TypeDefinitions.html#ga00034df66aefa8043fc1bf5f02ec9392">original::u_integer</a></div><div class="ttdeci">std::uint32_t u_integer</div><div class="ttdoc">32-bit unsigned integer type for sizes and indexes</div><div class="ttdef"><b>Definition</b> config.h:263</div></div>
<div class="ttc" id="agroup__TypeDefinitions_html_ga7016f36aa0d4425ae6207f689a421784"><div class="ttname"><a href="group__TypeDefinitions.html#ga7016f36aa0d4425ae6207f689a421784">original::integer</a></div><div class="ttdeci">std::int64_t integer</div><div class="ttdoc">64-bit signed integer type for arithmetic operations</div><div class="ttdef"><b>Definition</b> config.h:254</div></div>
<div class="ttc" id="anamespaceoriginal_html"><div class="ttname"><a href="namespaceoriginal.html">original</a></div><div class="ttdoc">Main namespace for the project Original.</div><div class="ttdef"><b>Definition</b> algorithms.h:21</div></div>
<div class="ttc" id="anamespaceoriginal_html_a176d8ed479959a50d637c2ee6900a159"><div class="ttname"><a href="namespaceoriginal.html#a176d8ed479959a50d637c2ee6900a159">original::operator+</a></div><div class="ttdeci">auto operator+(const iterator&lt; T &gt; &amp;it, integer steps) -&gt; iterator&lt; T &gt; *</div><div class="ttdoc">Adds a number of steps to the iterator's current position and returns a new iterator.</div></div>
<div class="ttc" id="anamespaceoriginal_html_ad9f68a800f874a16bc6a433ddcf06ed5"><div class="ttname"><a href="namespaceoriginal.html#ad9f68a800f874a16bc6a433ddcf06ed5">original::E</a></div><div class="ttdeci">constexpr long double E</div><div class="ttdoc">The mathematical constant E (Euler's number).</div><div class="ttdef"><b>Definition</b> maths.h:22</div></div>
<div class="ttc" id="aprintable_8h_html"><div class="ttname"><a href="printable_8h.html">printable.h</a></div><div class="ttdoc">Interface for polymorphic string formatting and output.</div></div>
<div class="ttc" id="atypes_8h_html"><div class="ttname"><a href="types_8h.html">types.h</a></div><div class="ttdoc">Core type system foundations and concept definitions.</div></div>
</div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
